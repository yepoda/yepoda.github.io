<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>web自动化测试（python+selenium）</title>
    <url>/2020/051852901.html</url>
    <content><![CDATA[<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="Python安装"><a href="#Python安装" class="headerlink" title="Python安装"></a>Python安装</h3><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p><a href="https://www.python.org/">https://www.python.org/</a></p>
<h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><h5 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> https://www.python.org/ftp/python/3.6.8/Python-3.6.8.tar.xz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h5 id="进行安装"><a href="#进行安装" class="headerlink" title="进行安装"></a>进行安装</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">　　　　<span class="token function">tar</span> xf Python-3.7.1.tar.xz
　　　　<span class="token builtin class-name">cd</span> Python-3.7.1
　　　　yum <span class="token parameter variable">-y</span> <span class="token function">install</span> gcc-* openssl-* libffi-devel sqlite-devel
　　　　./configure --enable-optimizations --with-openssl<span class="token operator">=</span>/usr/bin/openssl
　　　　<span class="token function">make</span> <span class="token parameter variable">-j4</span>
　　　　<span class="token function">make</span> <span class="token function">install</span>
　　　　默认安装路径：/usr/local/lib/python3.7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="更改安装源"><a href="#更改安装源" class="headerlink" title="更改安装源"></a>更改安装源</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip3 config <span class="token builtin class-name">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h5 id="升级pip"><a href="#升级pip" class="headerlink" title="升级pip"></a>升级pip</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip3 <span class="token function">install</span> <span class="token parameter variable">--upgrade</span> pip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h5 id="安装虚拟环境工具"><a href="#安装虚拟环境工具" class="headerlink" title="安装虚拟环境工具"></a>安装虚拟环境工具</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip3 <span class="token function">install</span> virtualenv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h5 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">virtualenv web01<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h5 id="切换到虚拟环境"><a href="#切换到虚拟环境" class="headerlink" title="切换到虚拟环境"></a>切换到虚拟环境</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> web01/bin/activate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h5 id="退出虚拟环境"><a href="#退出虚拟环境" class="headerlink" title="退出虚拟环境"></a>退出虚拟环境</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">　　　deactivate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h3><h4 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h4><p>打开dos窗口输入：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>正常应显示以下内容：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Usage:
  pip <span class="token operator">&lt;</span>command<span class="token operator">></span> <span class="token punctuation">[</span>options<span class="token punctuation">]</span>

Commands:
  <span class="token function">install</span>                     Install packages.
  download                    Download packages.
  uninstall                   Uninstall packages.
  freeze                      Output installed packages <span class="token keyword">in</span> requirements format.
  list                        List installed packages.
  show                        Show information about installed packages.
  check                       Verify installed packages have compatible dependencies.
  config                      Manage <span class="token builtin class-name">local</span> and global configuration.
  search                      Search PyPI <span class="token keyword">for</span> packages.
  wheel                       Build wheels from your requirements.
  <span class="token builtin class-name">hash</span>                        Compute hashes of package archives.
  completion                  A helper <span class="token builtin class-name">command</span> used <span class="token keyword">for</span> <span class="token builtin class-name">command</span> completion.
  <span class="token builtin class-name">help</span>                        Show <span class="token builtin class-name">help</span> <span class="token keyword">for</span> commands.

General Options:
  -h, <span class="token parameter variable">--help</span>                  Show help.
  <span class="token parameter variable">--isolated</span>                  Run pip <span class="token keyword">in</span> an isolated mode, ignoring environment variables and user configuration.
  -v, <span class="token parameter variable">--verbose</span>               Give <span class="token function">more</span> output. Option is additive, and can be used up to <span class="token number">3</span> times.
  -V, <span class="token parameter variable">--version</span>               Show version and exit.
  -q, <span class="token parameter variable">--quiet</span>                 Give <span class="token function">less</span> output. Option is additive, and can be used up to <span class="token number">3</span> <span class="token builtin class-name">times</span> <span class="token punctuation">(</span>corresponding to
                              WARNING, ERROR, and CRITICAL logging levels<span class="token punctuation">)</span>.
  <span class="token parameter variable">--log</span> <span class="token operator">&lt;</span>path<span class="token operator">></span>                Path to a verbose appending log.
  <span class="token parameter variable">--proxy</span> <span class="token operator">&lt;</span>proxy<span class="token operator">></span>             Specify a proxy <span class="token keyword">in</span> the form <span class="token punctuation">[</span>user:passwd@<span class="token punctuation">]</span>proxy.server:port.
  <span class="token parameter variable">--retries</span> <span class="token operator">&lt;</span>retries<span class="token operator">></span>         Maximum number of retries each connection should attempt <span class="token punctuation">(</span>default <span class="token number">5</span> <span class="token builtin class-name">times</span><span class="token punctuation">)</span>.
  <span class="token parameter variable">--timeout</span> <span class="token operator">&lt;</span>sec<span class="token operator">></span>             Set the socket <span class="token function">timeout</span> <span class="token punctuation">(</span>default <span class="token number">15</span> seconds<span class="token punctuation">)</span>.
  --exists-action <span class="token operator">&lt;</span>action<span class="token operator">></span>    Default action when a path already exists: <span class="token punctuation">(</span>s<span class="token punctuation">)</span>witch, <span class="token punctuation">(</span>i<span class="token punctuation">)</span>gnore, <span class="token punctuation">(</span>w<span class="token punctuation">)</span>ipe, <span class="token punctuation">(</span>b<span class="token punctuation">)</span>ackup,
                              <span class="token punctuation">(</span>a<span class="token punctuation">)</span>bort<span class="token punctuation">)</span>.
  --trusted-host <span class="token operator">&lt;</span>hostname<span class="token operator">></span>   Mark this <span class="token function">host</span> as trusted, even though it does not have valid or any HTTPS.
  <span class="token parameter variable">--cert</span> <span class="token operator">&lt;</span>path<span class="token operator">></span>               Path to alternate CA bundle.
  --client-cert <span class="token operator">&lt;</span>path<span class="token operator">></span>        Path to SSL client certificate, a single <span class="token function">file</span> containing the private key and the
                              certificate <span class="token keyword">in</span> PEM format.
  --cache-dir <span class="token operator">&lt;</span>dir<span class="token operator">></span>           Store the cache data <span class="token keyword">in</span> <span class="token operator">&lt;</span>dir<span class="token operator">></span>.
  --no-cache-dir              Disable the cache.
  --disable-pip-version-check
                              Don't periodically check PyPI to determine whether a new version of pip is available <span class="token keyword">for</span>
                              download. Implied with --no-index.
  --no-color                  Suppress colored output<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>dos输入在线安装selenium指令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> <span class="token assign-left variable">selenium</span><span class="token operator">==</span><span class="token number">2.53</span>.6<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h4><p>确保已经安装Firefox&#x2F;Chrome&#x2F;Ie浏览器中的一个</p>
<p>以Firefox为例（Firefox请安装46以下的版本），打开dos窗口输入指令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python
from selenium <span class="token function">import</span> webdriver
webdriver.Firefox<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>如果Firefox浏览器被调用启动，则表示selenium安装成功，其他浏览器请查阅“浏览器驱动”</p>
<h4 id="浏览器驱动"><a href="#浏览器驱动" class="headerlink" title="浏览器驱动"></a>浏览器驱动</h4><h5 id="Firefox"><a href="#Firefox" class="headerlink" title="Firefox"></a>Firefox</h5><p>请勿安装47以上的版本（selenium2不兼容47以上版本）</p>
<p>firefox历年版本的官方镜像地址：<br><a href="https://download-installer.cdn.mozilla.net/pub/firefox/releases/">https://download-installer.cdn.mozilla.net/pub/firefox/releases/</a></p>
<h5 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h5><p>selenium启动Chrome浏览器需要安装驱动包，不同的Chrome浏览器版本号对应的驱动文件版本号也不同，若不匹配，则无法启动。</p>
<p>查看Chrome版本号？</p>
<p>浏览器内：设置-&gt;关于-&gt;版本号</p>
<p>浏览器外：打开Chrome安装文件夹</p>
<p>Chrome浏览器chromedriver各版本驱动大全，下载地址：<br><a href="http://chromedriver.storage.googleapis.com/index.html">http://chromedriver.storage.googleapis.com/index.html</a></p>
<p>下载驱动成功后，确保chromedriver.exe文件放置于path路径下，我之前将环境变量配置到了python根目录，所以一般将chromedriver.exe放置于python安装的根目录。</p>
<h5 id="IE"><a href="#IE" class="headerlink" title="IE"></a>IE</h5><p>IE浏览器的IEdriver各版本驱动大全，下载地址：<br><a href="http://selenium-release.storage.googleapis.com/index.html">http://selenium-release.storage.googleapis.com/index.html</a></p>
<h2 id="selenium之webdriver框架"><a href="#selenium之webdriver框架" class="headerlink" title="selenium之webdriver框架"></a>selenium之webdriver框架</h2><h3 id="webdriver-API"><a href="#webdriver-API" class="headerlink" title="webdriver API"></a>webdriver API</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 导入webdriver模块</span>
<span class="token keyword">from</span> selenium <span class="token keyword">import</span> webdriver

<span class="token comment"># 导入计时器模块</span>
<span class="token keyword">import</span> time

<span class="token comment"># 打开Chrome浏览器</span>
<span class="token comment"># 其他浏览器替换浏览器名即可</span>
driver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 使用webdriver模块api导入网址</span>
driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"https://auntyang.tk"</span><span class="token punctuation">)</span>

<span class="token comment"># 计时器6s等待时间，一些异常报错可能就是因为没有在语句下设置等待时间</span>
<span class="token comment"># time模块的单位是s（秒），参数可以是小数也可以是整数</span>
time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>

<span class="token comment"># 截屏保存到指定目录，参数格式：保存路径+文件名称+后缀</span>
driver<span class="token punctuation">.</span>get_screenshot_as_file<span class="token punctuation">(</span><span class="token string">"D:\\test.jgp"</span><span class="token punctuation">)</span>

<span class="token comment"># 设置指定浏览器窗口尺寸</span>
driver<span class="token punctuation">.</span>set_window_size<span class="token punctuation">(</span><span class="token number">540</span><span class="token punctuation">,</span> <span class="token number">960</span><span class="token punctuation">)</span>
<span class="token comment"># 设置浏览器窗口最大化</span>
driver<span class="token punctuation">.</span>maximize_window<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 上一页，相当于浏览器左上角的左箭头按钮</span>
driver<span class="token punctuation">.</span>back<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment"># 下一页，相当于浏览器左上角的右箭头按钮</span>
driver<span class="token punctuation">.</span>forward<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 使用webdriver模块api进行刷新</span>
<span class="token comment"># 相当于浏览器输入框后面的刷新按钮</span>
driver<span class="token punctuation">.</span>refresh<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 结束浏览器进程</span>
driver<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment"># 关闭当前窗口</span>
driver<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="元素定位"><a href="#元素定位" class="headerlink" title="元素定位"></a>元素定位</h3><p>webdriver框架提供了18种元素定位方法，前8种通过元素属性定位，后10种通过xpan和css定位</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#id定位：</span>
find_element_by_id<span class="token punctuation">(</span>self<span class="token punctuation">,</span> id_<span class="token punctuation">)</span>
<span class="token comment">#name定位：</span>
find_element_by_name<span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span>
<span class="token comment">#class定位：</span>
find_element_by_class_name<span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span>
<span class="token comment">#tag定位：</span>
find_element_by_tag_name<span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span>
<span class="token comment">#link定位：</span>
find_element_by_link_text<span class="token punctuation">(</span>self<span class="token punctuation">,</span> link_text<span class="token punctuation">)</span>
<span class="token comment">#partial_link定位</span>
find_element_by_partial_link_text<span class="token punctuation">(</span>self<span class="token punctuation">,</span> link_text<span class="token punctuation">)</span>
<span class="token comment">#xpath定位：</span>
find_element_by_xpath<span class="token punctuation">(</span>self<span class="token punctuation">,</span> xpath<span class="token punctuation">)</span>
<span class="token comment">#css定位：</span>
find_element_by_css_selector<span class="token punctuation">(</span>self<span class="token punctuation">,</span> css_selector）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>复数形式：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#id复数定位</span>
find_elements_by_id<span class="token punctuation">(</span>self<span class="token punctuation">,</span> id_<span class="token punctuation">)</span>
<span class="token comment">#name复数定位</span>
find_elements_by_name<span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span>
<span class="token comment">#class复数定位</span>
find_elements_by_class_name<span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span>
<span class="token comment">#tag复数定位</span>
find_elements_by_tag_name<span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span>
<span class="token comment">#link复数定位</span>
find_elements_by_link_text<span class="token punctuation">(</span>self<span class="token punctuation">,</span> text<span class="token punctuation">)</span>
<span class="token comment">#partial_link复数定位</span>
find_elements_by_partial_link_text<span class="token punctuation">(</span>self<span class="token punctuation">,</span> link_text<span class="token punctuation">)</span>
<span class="token comment">#xpath复数定位</span>
find_elements_by_xpath<span class="token punctuation">(</span>self<span class="token punctuation">,</span> xpath<span class="token punctuation">)</span>
<span class="token comment">#css复数定位</span>
find_elements_by_css_selector<span class="token punctuation">(</span>self<span class="token punctuation">,</span> css_selector<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>参数化方法：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">find_element<span class="token punctuation">(</span>self<span class="token punctuation">,</span> by<span class="token operator">=</span><span class="token string">'id'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span>
find_elements<span class="token punctuation">(</span>self<span class="token punctuation">,</span> by<span class="token operator">=</span><span class="token string">'id'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="xpath定位"><a href="#xpath定位" class="headerlink" title="xpath定位"></a>xpath定位</h3><h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p>1.有时候同一个属性，同名的比较多，这时候可以通过标签筛选下，定位更准一点<br>2.如果不想制定标签名称，可以用*号表示任意标签<br>3.如果想制定具体某个标签，就可以直接写标签名称</p>
<h4 id="层级"><a href="#层级" class="headerlink" title="层级"></a>层级</h4><p>1.当某个元素属性不明显，无法直接定位时，可以先找其父元素</p>
<p>2.找到父元素后，向下一个层级就能定位到该元素</p>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>1.某元素标签和另一元素标签一样，且无法通过层级定位时，属于同父元素</p>
<p>2.同父元素的元素存在顺序，用索引定位</p>
<h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><p>1.xpath可以对多个属性进行逻辑运算，支持与（and）、或（or）、非（not）</p>
<h4 id="模糊匹配"><a href="#模糊匹配" class="headerlink" title="模糊匹配"></a>模糊匹配</h4><p>1.xpath可以对元素进行模糊匹配</p>
<h4 id="小测试"><a href="#小测试" class="headerlink" title="小测试"></a>小测试</h4><p>编写脚本，打开百度首页，输入关键字“robotframework”，点击搜索</p>
<p>结果如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20200523164846936.gif" alt="Web自动化测试"></p>
<h3 id="CSS定位"><a href="#CSS定位" class="headerlink" title="CSS定位"></a>CSS定位</h3><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>自动化测试</tag>
        <tag>python</tag>
        <tag>selenium</tag>
      </tags>
  </entry>
  <entry>
    <title>使用网络协议分析仪Wireshark</title>
    <url>/2020/051610680.html</url>
    <content><![CDATA[<h1 id="实验名称-使用网络协议分析仪Wireshark"><a href="#实验名称-使用网络协议分析仪Wireshark" class="headerlink" title="实验名称  使用网络协议分析仪Wireshark"></a>实验名称  使用网络协议分析仪Wireshark</h1><h2 id="实验目的："><a href="#实验目的：" class="headerlink" title="实验目的："></a>实验目的：</h2><ol>
<li>掌握安装和配置网络协议分析仪Wireshark的方法；</li>
<li>熟悉使用Wireshark工具分析网络协议的基本方法，加深对协议格式、协议层次和协议交互过程的理解。</li>
</ol>
<h2 id="实验内容和要求"><a href="#实验内容和要求" class="headerlink" title="实验内容和要求"></a>实验内容和要求</h2><pre class="line-numbers language-none"><code class="language-none">1. 安装和配置网络协议分析仪Wireshark（http:&#x2F;&#x2F;www.wireshark.org）；
	2. 使用并熟悉Wireshark分析协议的界面环境（菜单、工具条和各种窗口等）。
	3. 学会使用Wireshark捕捉协议包。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><pre class="line-numbers language-none"><code class="language-none">1.运行Windows 10专业版操作系统的PC机一台
	2.PC具有以太网卡一块，通过双绞线与局域网相连
	3.已安装Wireshark与Cisco Packet Tracer程序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="操作方法与实验步骤"><a href="#操作方法与实验步骤" class="headerlink" title="操作方法与实验步骤"></a>操作方法与实验步骤</h2><h3 id="1-安装网络协议分析仪"><a href="#1-安装网络协议分析仪" class="headerlink" title="1.安装网络协议分析仪"></a>1.安装网络协议分析仪</h3><p><img src="https://s2.loli.net/2023/03/26/PAIblrYFoBu4haO.png" alt="Wireshark首页"><br>安装成功并运行，进入主界面如图，（可以点击图片跳转Wireshark官网下载）我这里安装的版本是3.0.9，进入自动为中文界面，Wireshark进入后界面如上图没有任何本地接口，检查后发现未安装Winpacp，安装Winpacp后重启Wireshark，正常运行。</p>
<h3 id="2-使用Wireshark分析协议"><a href="#2-使用Wireshark分析协议" class="headerlink" title="2.使用Wireshark分析协议"></a>2.使用Wireshark分析协议</h3><h4 id="（1）点击Wireshark启动程序，正常运行如图"><a href="#（1）点击Wireshark启动程序，正常运行如图" class="headerlink" title="（1）点击Wireshark启动程序，正常运行如图"></a>（1）点击Wireshark启动程序，正常运行如图</h4><p><img src="https://img-blog.csdnimg.cn/20200516175003774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="Wireshark首页"><br>其中捕获和分析是最重要的功能</p>
<h4 id="（2）分组捕获"><a href="#（2）分组捕获" class="headerlink" title="（2）分组捕获"></a>（2）分组捕获</h4><p><img src="https://img-blog.csdnimg.cn/20200516191047640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="Wireshark捕获接口"><br>开始分组捕获之前选择捕获接口，我所使用的网络是网线接入电脑的有线网，所以我选择的是捕获接口是以太网。</p>
<h4 id="（3）协议分析。"><a href="#（3）协议分析。" class="headerlink" title="（3）协议分析。"></a>（3）协议分析。</h4><p><img src="https://img-blog.csdnimg.cn/20200516191115617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="Wireshark以太网监听"><br>监听以太网接口得到的报文信息，如上图，其中有一条黑色底色的TCP报文信息*。<br><img src="https://img-blog.csdnimg.cn/20200516191158370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="Wireshark以太网监听"><br>选择序号为191的一条报文信息进行分析，从蓝框可知该报文的发送源地址为223.166.151.88，目标地址为192.168.31.97，而目标地址192。168.31.97为我的专用网地址（路由器分配给笔记本的内网IP），源地址经查询地址为上海市，是一个公网IP，很明显该报文由外部网络发送至我的内网。<br>该报文的协议为OICQ，起初并不知道这个协议，但在中间信息框中发现该报文信息中包含了我的QQ号，由此推断OICQ为QQ通信协议，经过查询，OICQ为QQ的通讯协议，OICQ用户到OICQ服务器的通讯协议。<br><img src="https://img-blog.csdnimg.cn/20200516191237382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="Wireshark以太网监听"><br>进入191号报文信息具体页，可看到报文具体信息和十六进制和ASCI码形式的报文内容。<br>这一帧包包含一下四种信息：<br>Frame: 物理层的数据帧情况。<br>Ethernet II , Src: 数据链路层以太网帧头部信息。<br>Internet Protocol Version 4, Src: 互联网层IP包头信息。<br>Internet Control Message Protocol: 互联网控制信息协议。ping 小包所使用的协议。<br>前三层基本上都是一样的，第四层开始就可以出现TCP, UDP 协议，第五层就可能有HTTP 应用层协议等等。<br><img src="https://img-blog.csdnimg.cn/20200516191313947.png" alt="帧结构"><br>由该栏信息可知，该报文源地址服务器端口为8000，目标端口为4004，报文长度为127，总和校验码（Checksum）为0xe51f。<br><img src="https://img-blog.csdnimg.cn/20200516191327952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTc2NjIw,size_16,color_FFFFFF,t_70" alt="帧结构"><br>协议层信息，协议为OICQ（即时通讯软件协议）包含目标、版本、数据等信息。</p>
<h4 id="（4）保存分组捕获信息"><a href="#（4）保存分组捕获信息" class="headerlink" title="（4）保存分组捕获信息"></a>（4）保存分组捕获信息</h4><h2 id="实验数据记录和结果分析"><a href="#实验数据记录和结果分析" class="headerlink" title="实验数据记录和结果分析"></a>实验数据记录和结果分析</h2><p>实验数据与结果分析：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Frame <span class="token number">191</span>: <span class="token number">161</span> bytes on wire <span class="token punctuation">(</span><span class="token number">1288</span> bits<span class="token punctuation">)</span>, <span class="token number">161</span> bytes captured <span class="token punctuation">(</span><span class="token number">1288</span> bits<span class="token punctuation">)</span> on interface <span class="token number">0</span>
//第191帧，由161个字节在线，共1288位，实际捕获到161个字节在0接口
    Interface id: <span class="token number">0</span> <span class="token punctuation">(</span><span class="token punctuation">\</span>Device<span class="token punctuation">\</span>NPF_<span class="token punctuation">&#123;</span>7E2C33C0-0623-46BB-9126-813FB633578B<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>//接口ID：0
        Interface name: <span class="token punctuation">\</span>Device<span class="token punctuation">\</span>NPF_<span class="token punctuation">&#123;</span>7E2C33C0-0623-46BB-9126-813FB633578B<span class="token punctuation">&#125;</span>
        Interface description: <span class="token punctuation">\</span><span class="token number">344</span><span class="token punctuation">\</span><span class="token number">273</span><span class="token punctuation">\</span><span class="token number">245</span><span class="token punctuation">\</span><span class="token number">345</span><span class="token punctuation">\</span><span class="token number">244</span><span class="token punctuation">\</span><span class="token number">252</span><span class="token punctuation">\</span><span class="token number">347</span><span class="token punctuation">\</span><span class="token number">275</span><span class="token punctuation">\</span><span class="token number">221</span>
    Encapsulation type: Ethernet <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>//封装类型
    Arrival Time: Mar <span class="token number">13</span>, <span class="token number">2020</span> <span class="token number">15</span>:22:45.526314000 中国标准时间//到达时间
    <span class="token punctuation">[</span>Time <span class="token builtin class-name">shift</span> <span class="token keyword">for</span> this packet: <span class="token number">0.000000000</span> seconds<span class="token punctuation">]</span>//包偏移时间
    Epoch Time: <span class="token number">1584084165.526314000</span> seconds//不理解
    <span class="token punctuation">[</span>Time delta from previous captured frame: <span class="token number">0.027360000</span> seconds<span class="token punctuation">]</span>//两帧之间的时间间隔
    <span class="token punctuation">[</span>Time delta from previous displayed frame: <span class="token number">0.027360000</span> seconds<span class="token punctuation">]</span>//捕获到显示的间隔时间
    <span class="token punctuation">[</span>Time since reference or first frame: <span class="token number">3.969859000</span> seconds<span class="token punctuation">]</span>//此包和第一帧的时间间隔
    Frame Number: <span class="token number">191</span>//帧号
    Frame Length: <span class="token number">161</span> bytes <span class="token punctuation">(</span><span class="token number">1288</span> bits<span class="token punctuation">)</span>//帧长度
    Capture Length: <span class="token number">161</span> bytes <span class="token punctuation">(</span><span class="token number">1288</span> bits<span class="token punctuation">)</span>//捕获的帧长度
    <span class="token punctuation">[</span>Frame is marked: False<span class="token punctuation">]</span>//帧显著标志
    <span class="token punctuation">[</span>Frame is ignored: False<span class="token punctuation">]</span>//帧忽略标志
    <span class="token punctuation">[</span>Protocols <span class="token keyword">in</span> frame: eth:ethertype:ip:udp:oicq<span class="token punctuation">]</span>//帧内封装的协议层次结构
    <span class="token punctuation">[</span>Coloring Rule Name: UDP<span class="token punctuation">]</span>//着色标记的协议
    <span class="token punctuation">[</span>Coloring Rule String: udp<span class="token punctuation">]</span>//着色规则显示的字符串
Ethernet II, Src: XiaomiEl_ee:46:6f <span class="token punctuation">(</span><span class="token number">40</span>:31:3c:ee:46:6f<span class="token punctuation">)</span>, Dst: LcfcHefe_c2:10:c2 <span class="token punctuation">(</span>e8:6a:64:c2:10:c2<span class="token punctuation">)</span>
    Destination: LcfcHefe_c2:10:c2 <span class="token punctuation">(</span>e8:6a:64:c2:10:c2<span class="token punctuation">)</span>
        Address: LcfcHefe_c2:10:c2 <span class="token punctuation">(</span>e8:6a:64:c2:10:c2<span class="token punctuation">)</span>
        <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token punctuation">..</span><span class="token number">0</span>. <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token operator">=</span> LG bit: Globally unique address <span class="token punctuation">(</span>factory default<span class="token punctuation">)</span>
        <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token punctuation">..</span>.0 <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token operator">=</span> IG bit: Individual address <span class="token punctuation">(</span>unicast<span class="token punctuation">)</span>
    Source: XiaomiEl_ee:46:6f <span class="token punctuation">(</span><span class="token number">40</span>:31:3c:ee:46:6f<span class="token punctuation">)</span>
        Address: XiaomiEl_ee:46:6f <span class="token punctuation">(</span><span class="token number">40</span>:31:3c:ee:46:6f<span class="token punctuation">)</span>
        <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token punctuation">..</span><span class="token number">0</span>. <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token operator">=</span> LG bit: Globally unique address <span class="token punctuation">(</span>factory default<span class="token punctuation">)</span>
        <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token punctuation">..</span>.0 <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token operator">=</span> IG bit: Individual address <span class="token punctuation">(</span>unicast<span class="token punctuation">)</span>
    Type: IPv4 <span class="token punctuation">(</span>0x0800<span class="token punctuation">)</span>
Internet Protocol Version <span class="token number">4</span>, Src: <span class="token number">223.166</span>.151.88, Dst: <span class="token number">192.168</span>.31.97
    0100 <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token operator">=</span> Version: <span class="token number">4</span>
    <span class="token punctuation">..</span><span class="token punctuation">..</span> 0101 <span class="token operator">=</span> Header Length: <span class="token number">20</span> bytes <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
    Differentiated Services Field: 0x00 <span class="token punctuation">(</span>DSCP: CS0, ECN: Not-ECT<span class="token punctuation">)</span>
        0000 00<span class="token punctuation">..</span> <span class="token operator">=</span> Differentiated Services Codepoint: Default <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token punctuation">..</span>00 <span class="token operator">=</span> Explicit Congestion Notification: Not ECN-Capable Transport <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    Total Length: <span class="token number">147</span>
    Identification: 0x8fa2 <span class="token punctuation">(</span><span class="token number">36770</span><span class="token punctuation">)</span>
    Flags: 0x4000, Don<span class="token string">'t fragment
        0... .... .... .... = Reserved bit: Not set
        .1.. .... .... .... = Don'</span>t fragment: Set
        <span class="token punctuation">..</span><span class="token number">0</span>. <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token operator">=</span> More fragments: Not <span class="token builtin class-name">set</span>
    <span class="token punctuation">..</span>.0 0000 0000 0000 <span class="token operator">=</span> Fragment offset: <span class="token number">0</span>
    Time to live: <span class="token number">52</span>
    Protocol: UDP <span class="token punctuation">(</span><span class="token number">17</span><span class="token punctuation">)</span>
    Header checksum: 0x5faf <span class="token punctuation">[</span>validation disabled<span class="token punctuation">]</span>
    <span class="token punctuation">[</span>Header checksum status: Unverified<span class="token punctuation">]</span>
    Source: <span class="token number">223.166</span>.151.88
    Destination: <span class="token number">192.168</span>.31.97
User Datagram Protocol, Src Port: <span class="token number">8000</span>, Dst Port: <span class="token number">4004</span>
    Source Port: <span class="token number">8000</span>//源IP
    Destination Port: <span class="token number">4004</span>//目标IP
    Length: <span class="token number">127</span>//长度
    Checksum: 0xe51f <span class="token punctuation">[</span>unverified<span class="token punctuation">]</span>//和校验
    <span class="token punctuation">[</span>Checksum Status: Unverified<span class="token punctuation">]</span>//和校验状态
    <span class="token punctuation">[</span>Stream index: <span class="token number">0</span><span class="token punctuation">]</span>
    <span class="token punctuation">[</span>Timestamps<span class="token punctuation">]</span>
        <span class="token punctuation">[</span>Time since first frame: <span class="token number">3.969859000</span> seconds<span class="token punctuation">]</span>
        <span class="token punctuation">[</span>Time since previous frame: <span class="token number">0.031141000</span> seconds<span class="token punctuation">]</span>
OICQ - IM software, popular <span class="token keyword">in</span> China//因特网控制信息协议
    Flag: Oicq packet <span class="token punctuation">(</span>0x02<span class="token punctuation">)</span>
    Version: 0x3859//版本信息
    Command: Heart Message <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
    Sequence: <span class="token number">17154</span>
    Data<span class="token punctuation">(</span>OICQ Number,if sender is client<span class="token punctuation">)</span>: <span class="token number">1026651458</span>
    Data: 
        <span class="token punctuation">[</span>Expert Info <span class="token punctuation">(</span>Warning/Undecoded<span class="token punctuation">)</span>: Trailing stray characters<span class="token punctuation">]</span>
            <span class="token punctuation">[</span>Trailing stray characters<span class="token punctuation">]</span>
            <span class="token punctuation">[</span>Severity level: Warning<span class="token punctuation">]</span>
            <span class="token punctuation">[</span>Group: Undecoded<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>实验</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>WPF开发小记</title>
    <url>/2020/0907WPF-dev.html</url>
    <content><![CDATA[<h1 id="C-基本"><a href="#C-基本" class="headerlink" title="C#基本"></a>C#基本</h1><p>C#是一种面向对象的编程语言。在面向对象的程序设计方法中,程序有各种相互交互的对象组成。相同种类的对象通常具有相同的类型,或者说,在同一Class中。</p>
<h2 id="C-代码基本结构"><a href="#C-代码基本结构" class="headerlink" title="C#代码基本结构"></a>C#代码基本结构</h2><h3 id="using关键字"><a href="#using关键字" class="headerlink" title="using关键字"></a>using关键字</h3><p>在任何C#程序中的第一条语句都是:</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using system<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>using关键字用于在程序中包含命名空间,一个程序可以包含多个using语句。</p>
<h3 id="class关键字"><a href="#class关键字" class="headerlink" title="class关键字"></a>class关键字</h3><p>class关键字用于声明一个<strong>类</strong>,<strong>类</strong>是一种数据结构,可以封装数据成员、方法成员和其他的类。</p>
<p>C#中所有的语句都必须包含在类中。</p>
<p>类名是一种标识符,必须符合标识符的命名规则。</p>
<h3 id="Main方法"><a href="#Main方法" class="headerlink" title="Main方法"></a>Main方法</h3><p>一个C#程序中只能有一个入口点(Mian方法)</p>
<p>Main方法<strong>默认访问级别</strong>为private</p>
<p>可以用三种修饰符修饰Main方法:Pubic,Static,Void<br>Public:说明Mian方法是公有的,在类的外面也可以调用该方法。<br>Static:说明Main方法是一个静态方法,即这个方法属于类的本身而不是这个类的特定对象。调用静态方法不能使用类的实例化对象,必须直接使用类名来调用。<br>Void:说明Main方法是无返回值的</p>
<p>在Main方法中捕获异常信息并输出:try……catch(Exception)</p>
<h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>变量是类的属性或数据成员,用于存储数据。</p>
<h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><p>函数是一系列执行指定任务的语句,类的成员函数是在类内生命的</p>
<h3 id="实例化类"><a href="#实例化类" class="headerlink" title="实例化类"></a>实例化类</h3><p>类是一个概念,只有将类实例化才能够实际上读取数据成员或者成员函数</p>
<h3 id="设置版本和帮助信息"><a href="#设置版本和帮助信息" class="headerlink" title="设置版本和帮助信息"></a>设置版本和帮助信息</h3><p>为C#程序设置版本和帮助信息,在“解决方案资源管理器”中找到</p>
<h2 id="C-数据类型"><a href="#C-数据类型" class="headerlink" title="C#数据类型"></a>C#数据类型</h2><h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><p>值类型变量可以直接分配给一个值,值类型直接包含数据。</p>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>引用类型不包含存储在变量中的实际数据,但它们包含对变量的引用。</p>
<p>换句话说,它们指的是一个内存位置。使用多个变量时,引用类型可以指向一个内存位置。如果内存位置的数据是有一个变量改变的,其他变量会自动反映这种值的变化。<strong>内置的</strong>引用类型有:object、dynamic、string</p>
<h2 id="Try…Catch…"><a href="#Try…Catch…" class="headerlink" title="Try…Catch…"></a>Try…Catch…</h2><p>1、代码放到try快中(try是c#的关键字)。代码运行是,会尝试执行try块内部的语句,如果么有语句发生异常,这些语句将顺序执行下去。直到全部都完成,但是一旦出现异常就跳出try块,执行catch块中的内容。</p>
<p>2、try块需要一个或者多个catch块程序捕捉并处理特定类型的异常。</p>
<h2 id="InitializeComponent-方法"><a href="#InitializeComponent-方法" class="headerlink" title="InitializeComponent()方法"></a>InitializeComponent()方法</h2><p>InitializeComponent()方法:由系统生成的对窗体界面的定义方法</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public MainWindow()
&#123;
    InitializeComponent();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="InitializeComponent方法定义哪里"><a href="#InitializeComponent方法定义哪里" class="headerlink" title="InitializeComponent方法定义哪里"></a><a href="https://www.cnblogs.com/cnblogsfans/archive/2011/02/19/1958575.html">InitializeComponent方法定义哪里</a></h2><p>我们定位到那个方法转到定义,发现没反应。</p>
<p>实际上这个方法是编译时WPF会为我自动生成,编译后在下面红色标注的地方打开MainWindow.g.cs,在这个文件可以找到这个方法的定义</p>
<p><img src="https://images.cnblogs.com/cnblogs_com/cnblogsfans/201102/201102191634297448.png"></p>
<p>在每个窗口建立后,都会同时产生程序代码文件,即.cs文件,以及与之相匹配的.Designer.CS文件,业务逻辑以及事件方法等被编写在.CS文件中,而界面设计规则被封装在.Designer.CS文件中</p>
<p>InitializeComponent()方法和Dispose()方法,前者为界面设计的变现内容,后者为表单释放系统资源时候执行编码。</p>
<p>InitializeComponent()方法反映了窗体设计器中窗体和控件的属性。通常不会在这个文件中修改代码。如果更改InitializeComponent()方法中的相关属性参数,在窗体设计器界面上也会显示出来。</p>
<p>partial 表示以下创建的是分布类代码<br>也就是说 一个类的定义代码 可以写在两个不同的页面<br>Form1.cs和Form1.Designer.cs</p>
<p>注意:InitializeComponent()方法写在前面和后面是有区别的。InitializeComponent()方法是用来初始化窗体组件的,在InitializeComponent之前,窗体的各个控件还没有进行初始化,比如说窗体上有一个TextBoxUserName,在InitializeComponent之前它还只是一个TextBox类型的变量而已,如果在InitializeComponent之前调用这个TextBox的属性或方法,就会出错。再比如说你拖上取一个TextBox,它放在Form的位置,TextBox的一些属性。包括new 这个TextBox都放在那个函数里面处理的。</p>
<p>我们可以看一下Form.Designer.cs,在那里找到InitializeComponent方法,您会发现窗体对象的初始化都是在那里做的。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>基本的类型转换:<a href="https://www.runoob.com/csharp/csharp-type-conversion.html">https://www.runoob.com/csharp/csharp-type-conversion.html</a></p>
<p>类型转换:<a href="https://www.cnblogs.com/minotauros/p/11440040.html">https://www.cnblogs.com/minotauros/p/11440040.html</a></p>
<p>讲解的比较详细:<a href="https://blog.csdn.net/wu_l_v/article/details/78989303">https://blog.csdn.net/wu_l_v/article/details/78989303</a></p>
<h1 id="C-文件读写"><a href="#C-文件读写" class="headerlink" title="C#文件读写"></a>C#文件读写</h1><h2 id="添加命名控件"><a href="#添加命名控件" class="headerlink" title="添加命名控件"></a>添加命名控件</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">System.IO;
System.Text;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h2><p>使用FileStream类进行文件的读取 ,并将它转换成char数组,然后输出</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">byte[] byData &#x3D; new byte[100];
char[] charData &#x3D; new char[1000];
public void Read()
&#123;
  try
   &#123;
     FileStream file &#x3D; new FileStream(&quot;E:\\test.txt&quot;, FileMode.Open);
     file.Seek(0, SeekOrigin.Begin);
     file.Read(byData, 0, 100);      &#x2F;&#x2F;byData传进来的字节数组,用以接受FileStream对象中的数据,第2个参数是字节数组中开始写入数据的位置,它通常是0,     &#x2F;&#x2F;表示从数组的开端文件中向数组写数据,最后一个参数规定从文件读多少字符.
     Decoder d &#x3D; Encoding.Default.GetDecoder();
     d.GetChars(byData, 0, byData.Length, charData, 0);
     Console.WriteLine(charData);
     file.Close();
    &#125;
   catch (IOException e)
   &#123;
      Console.WriteLine(e.ToString());
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用StreamReader读取文件,然后一行一行的输出。</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public void Read(string path)
&#123;
    StreamReader sr &#x3D; new StreamReader(path,Encoding.Default);
    String line;
    while ((line &#x3D; sr.ReadLine()) !&#x3D; null) 
    &#123;
     Console.WriteLine(line.ToString());
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h2><p>使用FileStream类创建文件,然后将数据写入到文件里。</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public void Write()
&#123;
   &#x2F;&#x2F;FileMode.Append为不覆盖文件效果.create为覆盖   FileStream fs &#x3D; new FileStream(&quot;E:\\ak.txt&quot;, FileMode.Create);
   &#x2F;&#x2F;获得字节数组
   byte[] data &#x3D; System.Text.Encoding.Default.GetBytes(&quot;Hello World!&quot;); 
   &#x2F;&#x2F;开始写入
   fs.Write(data, 0, data.Length);
   &#x2F;&#x2F;清空缓冲区、关闭流
   fs.Flush();
   fs.Close();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用FileStream类创建文件,使用StreamWriter类,将数据写入到文件。</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public void Write(string path)
&#123;
   FileStream fs &#x3D; new FileStream(path, FileMode.Create);
   StreamWriter sw &#x3D; new StreamWriter(fs);
   sw.Write(&quot;Hello World!!!!&quot;);&#x2F;&#x2F;开始写入
   sw.Flush();&#x2F;&#x2F;清空缓冲区
   sw.Close();&#x2F;&#x2F;关闭流
   fs.Close();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="C-List介绍"><a href="#C-List介绍" class="headerlink" title="C# List介绍"></a>C# List介绍</h1><h2 id="一、LIST概述"><a href="#一、LIST概述" class="headerlink" title="一、LIST概述"></a><strong>一、LIST概述</strong></h2><p>**所属命名空间:**System.Collections.Generic</p>
<p>public class List<T> : IList<T>, ICollection<T>, IEnumerable<T>, IList, ICollection, IEnumerable</p>
<p><a href="http://msdn.microsoft.com/zh-cn/library/5y536ey6.aspx">List</a>类是 <a href="http://msdn.microsoft.com/zh-cn/library/system.collections.arraylist.aspx">ArrayList</a> 类的泛型等效类。该类使用大小可按需动态增加的数组实现 <a href="http://msdn.microsoft.com/zh-cn/library/5y536ey6.aspx">IList</a> 泛型接口。</p>
<p><strong>泛型的好处</strong>: 它为使用c#语言编写面向对象程序增加了极大的效力和灵活性。不会强行对值类型进行装箱和拆箱,或对引用类型进行向下强制类型转换,所以性能得到提高。</p>
<h2 id="二、性能注意事项"><a href="#二、性能注意事项" class="headerlink" title="二、性能注意事项:"></a><strong>二、性能注意事项:</strong></h2><p><strong>在决定使用</strong><a href="http://msdn.microsoft.com/zh-cn/library/5y536ey6.aspx"><strong>IList</strong></a> <strong>还是使用</strong><a href="http://msdn.microsoft.com/zh-cn/library/system.collections.arraylist.aspx"><strong>ArrayList</strong></a><strong>类(两者具有类似的功能)时,记住</strong><a href="http://msdn.microsoft.com/zh-cn/library/5y536ey6.aspx"><strong>IList</strong></a> 类在大多数情况下执行得更好并且是类型安全的。</p>
<p>如果对<a href="http://msdn.microsoft.com/zh-cn/library/5y536ey6.aspx">IList</a> 类的类型 T 使用引用类型,则两个类的行为是完全相同的。但是,如果对类型 T 使用值类型,则需要考虑实现和装箱问题。</p>
<p>“添加到 ArrayList 中的任何引用或值类型都将隐式地向上强制转换为 Object。如果项是值类型,则必须在将其添加到列表中时进行装箱操作,在检索时进行取消装箱操作。强制转换以及装箱和取消装箱操作都会降低性能;在必须对大型集合进行循环访问的情况下,装箱和取消装箱的影响非常明显。”</p>
<h2 id="三、一般用法"><a href="#三、一般用法" class="headerlink" title="三、一般用法"></a><strong>三、一般用法</strong></h2><p><strong>List</strong>的基础、常用方法:</p>
<p><strong>声明:</strong></p>
<p>1、List<T> mList &#x3D; new List<T>();</p>
<p>T为列表中元素类型,现在以string类型作为例子</p>
<p>E.g.: List<string> mList &#x3D; new List<string>();</p>
<p>2、List<T> testList &#x3D;new List<T> (IEnumerable<T> collection);</p>
<p>以一个集合作为参数创建List</p>
<p>E.g.:</p>
<p>string[] temArr &#x3D; { “Ha”, “Hunter”, “Tom”, “Lily”, “Jay”, “Jim”, “Kuku”, “Locu” };</p>
<p>List<string> testList &#x3D; new List<string>(temArr);</p>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a><strong>添加元素</strong></h3><p>1、 List. Add(T item)  添加一个元素</p>
<p>E.g.:  mList.Add(“John”);</p>
<p>2、 List. AddRange(IEnumerable<T> collection)  添加一组元素</p>
<p>E.g.:</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">string[] temArr &#x3D; &#123; &quot;Ha&quot;,&quot;Hunter&quot;, &quot;Tom&quot;, &quot;Lily&quot;, &quot;Jay&quot;, &quot;Jim&quot;, &quot;Kuku&quot;, &quot;Locu&quot; &#125;;

mList.AddRange(temArr);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>3、Insert(int index, T item);  在index位置添加一个元素</p>
<p>E.g.:  mList.Insert(1, “Hei”);</p>
<h3 id="遍历List中元素"><a href="#遍历List中元素" class="headerlink" title="遍历List中元素"></a>遍历List中元素</h3><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">foreach (T element in mList) &#x2F;&#x2F;T的类型与mList声明时一样

 &#123;

   Console.WriteLine(element);

 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>E.g.:</p>
<p>foreach (string s in mList)</p>
<p>{</p>
<p>Console.WriteLine(s);</p>
<p>}</p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>1、 List. Remove(T item)    删除一个值</p>
<p>E.g.:  mList.Remove(“Hunter”);</p>
<p>2、 List. RemoveAt(int index);  删除下标为index的元素</p>
<p>E.g.:  mList.RemoveAt(0);</p>
<p>3、 List. RemoveRange(int index, int count);</p>
<p>从下标index开始,删除count个元素</p>
<p>E.g.:  mList.RemoveRange(3, 2);</p>
<h3 id="判断某个元素是否在该List"><a href="#判断某个元素是否在该List" class="headerlink" title="判断某个元素是否在该List"></a>判断某个元素是否在该List</h3><p>List. Contains(T item)  返回true或false,很实用</p>
<p>E.g.:</p>
<p>if (mList.Contains(“Hunter”))</p>
<p>{</p>
<p>Console.WriteLine(“There is Hunter in the list”);</p>
<p>}</p>
<p>else</p>
<p>{</p>
<p>mList.Add(“Hunter”);</p>
<pre class="line-numbers language-none"><code class="language-none">Console.WriteLine(&quot;Add Hunter successfully.&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<p>}</p>
<h3 id="给List里面元素排序"><a href="#给List里面元素排序" class="headerlink" title="给List里面元素排序"></a>给List里面元素排序</h3><p>List. Sort ()  默认是元素第一个字母按升序</p>
<p>E.g.:  mList.Sort();</p>
<h3 id="给List里面元素顺序反转"><a href="#给List里面元素顺序反转" class="headerlink" title="给List里面元素顺序反转"></a>给List里面元素顺序反转</h3><p>List. Reverse ()  可以与List. Sort ()配合使用,达到想要的效果</p>
<p>E.g.:  mList.Sort();</p>
<h3 id="List清空"><a href="#List清空" class="headerlink" title="List清空"></a>List清空</h3><p>List. Clear ()</p>
<p>E.g.:  mList.Clear();</p>
<h3 id="获得List中元素数目"><a href="#获得List中元素数目" class="headerlink" title="获得List中元素数目"></a>获得List中元素数目</h3><p>List. Count ()  返回int值</p>
<p>E.g.:</p>
<p>int count &#x3D; mList.Count();</p>
<pre class="line-numbers language-none"><code class="language-none">Console.WriteLine(&quot;The num of elements in the list: &quot; +count);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<h2 id="List的进阶、强大方法"><a href="#List的进阶、强大方法" class="headerlink" title="List的进阶、强大方法"></a>List的进阶、强大方法</h2><p>举例用的List:</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">string[] temArr &#x3D; &#123; Ha&quot;,&quot;Hunter&quot;, &quot;Tom&quot;, &quot;Lily&quot;, &quot;Jay&quot;, &quot;Jim&quot;, &quot;Kuku&quot;, &quot; &quot;Locu&quot; &#125;;

mList.AddRange(temArr);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="List-Find方法"><a href="#List-Find方法" class="headerlink" title="List.Find方法"></a>List.Find方法</h3><p>搜索与指定谓词所定义的条件相匹配的元素,并返回整个 List 中的第一个匹配元素。</p>
<p>public T Find(Predicate<T> match);</p>
<p>Predicate是对方法的委托,如果传递给它的对象与委托中定义的条件匹配,则该方法返回 true。当前 List 的元素被逐个传递给Predicate委托,并在 List 中向前移动,从第一个元素开始,到最后一个元素结束。当找到匹配项时处理即停止。</p>
<p>Predicate 可以委托给一个函数或者一个拉姆达表达式:</p>
<p>委托给拉姆达表达式:</p>
<p>E.g.:</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">string listFind &#x3D; mList.Find(name &#x3D;&gt; &#x2F;&#x2F;name是变量,代表的是mList

  &#123;               &#x2F;&#x2F;中元素,自己设定

    if (name.Length &gt; 3)

    &#123;

      return true;

    &#125;

      return false;

   &#125;);

   Console.WriteLine(listFind);   &#x2F;&#x2F;输出是Hunter<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>委托给一个函数:</p>
<p>E.g.:</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">string listFind1 &#x3D; mList.Find(ListFind); &#x2F;&#x2F;委托给ListFind函数

Console.WriteLine(listFind);      &#x2F;&#x2F;输出是Hunter<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="ListFind函数"><a href="#ListFind函数" class="headerlink" title="ListFind函数"></a>ListFind函数</h3><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public bool ListFind(string name)

&#123;

  if (name.Length &gt; 3)

    &#123;

     return true;

    &#125;

      return false;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这两种方法的结果是一样的。</p>
<h3 id="List-FindLast方法"><a href="#List-FindLast方法" class="headerlink" title="List.FindLast方法"></a>List.FindLast方法</h3><p>搜索与指定谓词所定义的条件相匹配的元素,并返回整个 List 中的最后一个匹配元素。</p>
<p>public T FindLast(Predicate<T> match);</p>
<p>用法与List.Find相同。</p>
<h3 id="List-TrueForAll方法"><a href="#List-TrueForAll方法" class="headerlink" title="List.TrueForAll方法"></a>List.TrueForAll方法</h3><p>确定是否 <a href="http://msdn.microsoft.com/en-us/6sh2ey19(zh-cn,VS.85).aspx">List</a> 中的每个元素都与指定的谓词所定义的条件相匹配。</p>
<p>public bool TrueForAll(Predicate<T> match);</p>
<p>委托给拉姆达表达式:</p>
<p>E.g.:</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">bool flag &#x3D; mList.TrueForAll(name &#x3D;&gt;

  &#123;

    if (name.Length &gt; 3)

    &#123;

     return true;

    &#125;

    else

     &#123;

      return false;

      &#125;

   &#125;

 );

 Console.WriteLine(&quot;True for all: &quot;+flag); &#x2F;&#x2F;flag值为false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>委托给一个函数,这里用到上面的<strong>ListFind</strong>函数:</p>
<p>E.g.:</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#"> bool flag &#x3D; mList.TrueForAll(ListFind); &#x2F;&#x2F;委托给ListFind函数

Console.WriteLine(&quot;True for all: &quot;+flag); &#x2F;&#x2F;flag值为false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>这两种方法的结果是一样的。</p>
<h3 id="List-FindAll方法"><a href="#List-FindAll方法" class="headerlink" title="List.FindAll方法"></a>List.FindAll方法</h3><p>检索与指定谓词所定义的条件相匹配的所有元素。</p>
<p>public List<T> FindAll(Predicate<T> match);</p>
<p>E.g.:</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">List&lt;string&gt; subList &#x3D; mList.FindAll(ListFind); &#x2F;&#x2F;委托给ListFind函数

 foreach (string s in subList)

  &#123;

   Console.WriteLine(&quot;element in subList: &quot;+s);

  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">这时subList存储的就是所有长度大于3的元素<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<h3 id="List-Take-n"><a href="#List-Take-n" class="headerlink" title="List.Take(n)"></a>List.Take(n)</h3><p>获得前n行 返回值为IEnumetable<T>,T的类型与List<T>的类型一样</p>
<p>E.g.:</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">IEnumerable&lt;string&gt; takeList&#x3D; mList.Take(5);

foreach (string s in takeList)

 &#123;

   Console.WriteLine(&quot;element in takeList: &quot; + s);

 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">这时takeList存放的元素就是mList中的前5个<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<h3 id="List-Where方法"><a href="#List-Where方法" class="headerlink" title="List.Where方法"></a>List.Where方法</h3><p>检索与指定谓词所定义的条件相匹配的所有元素。跟List.FindAll方法类似。</p>
<p>E.g.:</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">IEnumerable&lt;string&gt; whereList &#x3D; mList.Where(name &#x3D;&gt;

     &#123;

        if (name.Length &gt; 3)

        &#123;

          return true;

        &#125;

        else

        &#123;

          return false;

        &#125;

     &#125;);

   foreach (string s in subList)

   &#123;

     Console.WriteLine(&quot;element in subList: &quot;+s);

   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">这时subList存储的就是所有长度大于3的元素<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<h3 id="List-RemoveAll方法"><a href="#List-RemoveAll方法" class="headerlink" title="List.RemoveAll方法"></a>List.RemoveAll方法</h3><p>移除与指定的谓词所定义的条件相匹配的所有元素。</p>
<p>public int RemoveAll(Predicate<T> match);</p>
<p>E.g.:</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">mList.RemoveAll(name &#x3D;&gt;

       &#123;

         if (name.Length &gt; 3)

         &#123;

           return true;

         &#125;

         else

         &#123;

           return false;

         &#125;

       &#125;);

     foreach (string s in mList)

     &#123;

       Console.WriteLine(&quot;element in mList:   &quot; + s);

     &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这时mList存储的就是移除长度大于3之后的元素。</p>
<p>List<T> 是一个泛型链表…T表示节点元素类型<br>比如<br>List<int> intList;表示一个元素为int的链表<br>intList.Add(34); &#x2F;&#x2F;添加<br>intList.Remove(34);&#x2F;&#x2F;删除<br>intList.RemoveAt(0); &#x2F;&#x2F;删除位于某处的元素<br>intList.Count; &#x2F;&#x2F;链表长度<br>还有Insert,Find,FindAll,Contains等方法,也有索引方法 intList[0] &#x3D; 23;</p>
<p>1.减少了装箱拆箱<br>2.便于编译时检查数据类型</p>
<p>List<Object> 就相当于 System.Collections命名空间里面的List</p>
<h2 id="C-List和string-之间的相互转换"><a href="#C-List和string-之间的相互转换" class="headerlink" title="C#List和string[]之间的相互转换"></a>C#List<string>和string[]之间的相互转换</h2><p>1.从System.String[]转到List&lt;System.String&gt;</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">List&lt;System.String&gt; List &#x3D; new List&lt;System.String&gt;(); string[] str&#x3D;&#123;&quot;1&quot;,&quot;2&quot;,&quot;3&quot;&#125;;
List &#x3D; new List&lt;System.String&gt;(str);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>2.从List&lt;System.String&gt;转到System.String[]</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">List&lt;System.String&gt; List &#x3D; new List&lt;System.String&gt;(); List.Add(&quot;1&quot;);
List.Add(&quot;2&quot;);
List.Add(&quot;3&quot;);&#x2F;&#x2F;添加数据
System.String[] str &#x3D; &#123; &#125;;
str &#x3D; List.ToArray();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>3.字符串数组可以,其他有些类型像int数组等等的也是可以的。</p>
<h1 id="C-字符分割"><a href="#C-字符分割" class="headerlink" title="C# 字符分割"></a>C# 字符分割</h1><h2 id="Split-函数"><a href="#Split-函数" class="headerlink" title="Split()函数"></a>Split()函数</h2><p>Split方法提供了字符分割的几种方法</p>
<p>String.Split方法提供了如下6个重载函数:</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="http://blog.csdn.net/chen_zw/article/details/M_System_String_Split_1_86599791.htm">String.Split (Char[])</a></td>
<td align="left">返回包含此实例中的子字符串(由指定 Char 数组的元素分隔)的 String 数组。由 .NET Compact Framework 支持。</td>
</tr>
<tr>
<td align="left"><a href="http://blog.csdn.net/chen_zw/article/details/M_System_String_Split_1_d4a51604.htm">String.Split (Char[], Int32)</a></td>
<td align="left">返回包含此实例中的子字符串(由指定 Char 数组的元素分隔)的 String 数组。参数指定返回的子字符串的最大数量。</td>
</tr>
<tr>
<td align="left"><a href="http://blog.csdn.net/chen_zw/article/details/M_System_String_Split_1_0b4c5fa1.htm">String.Split (Char[], StringSplitOptions)</a></td>
<td align="left">返回包含此字符串中的子字符串(由指定的 Char 数组的元素分隔)的 String 数组。参数指定是否返回空数组元素。</td>
</tr>
<tr>
<td align="left"><a href="http://blog.csdn.net/chen_zw/article/details/M_System_String_Split_2_f66d5c6c.htm">String.Split (String[], StringSplitOptions)</a></td>
<td align="left">返回包含此字符串中的子字符串(由指定的 String 数组的元素分隔)的 String 数组。参数指定是否返回空数组元素。</td>
</tr>
<tr>
<td align="left"><a href="http://blog.csdn.net/chen_zw/article/details/M_System_String_Split_1_7399acf4.htm">String.Split (Char[], Int32, StringSplitOptions)</a></td>
<td align="left">返回包含此字符串中的子字符串(由指定的 Char 数组的元素分隔)的 String 数组。参数指定要返回子字符串的最大数量,以及是否要返回空数组元素。</td>
</tr>
<tr>
<td align="left"><a href="http://blog.csdn.net/chen_zw/article/details/M_System_String_Split_2_42368699.htm">String.Split (String[], Int32, StringSplitOptions)</a></td>
<td align="left">返回包含此字符串中的子字符串(由指定的 String 数组的元素分隔)的 String 数组。参数指定要返回子字符串的最大数量,以及是否要返回空数组元素。</td>
</tr>
</tbody></table>
<p>以下详细举例说明:</p>
<h3 id="String-Split-Char"><a href="#String-Split-Char" class="headerlink" title="String.Split(Char[])"></a>String.Split(Char[])</h3><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">string str &#x3D; &quot;aaatbbscctdd&quot;;

string []strArray &#x3D; str.Split(new char[]&#123;&#39;t&#39;&#125;); 或string []strArray &#x3D; str.Split(&#39;t&#39;); &#x2F;&#x2F;单字符切割(result : &quot;aaa&quot; &quot;bbscc&quot; &quot;dd&quot;)

string []strArray &#x3D; str.Split(new char[]&#123;&#39;t&#39;,&#39;s&#39;&#125;); &#x2F;&#x2F;多字节切割(result : &quot;aaa&quot; &quot;bb&quot; &quot;cc&quot; &quot;dd&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="String-Split-Char-Int32"><a href="#String-Split-Char-Int32" class="headerlink" title="String.Split(Char[],Int32)"></a>String.Split(Char[],Int32)</h3><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">string str &#x3D; &quot;aaatbbscctdd&quot;;

string []strArray &#x3D; str.Split(new char[]&#123;&#39;t&#39;,2&#125;);&#x2F;&#x2F;只切割成2份(result :&quot;aaa&quot; &quot;bbscctdd&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="String-Split-Char-StringSplitOptions"><a href="#String-Split-Char-StringSplitOptions" class="headerlink" title="String.Split(Char[],StringSplitOptions)"></a>String.Split(Char[],StringSplitOptions)</h3><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">string str &#x3D; &quot;aaatbbscctddt&quot;;

string []strArray &#x3D; str.Split(new char[]&#123;&#39;t&#39;,StringSplitOptions.RemoveEmptyEntries&#125;);&#x2F;&#x2F;去除空元素(result :&quot;aaa&quot; &quot;bbscc&quot; &quot;dd&quot;)

string []strArray &#x3D; str.Split(new char[]&#123;&#39;t&#39;,StringSplitOptions.None&#125;);&#x2F;&#x2F;保留空元素(result :&quot;aaa&quot; &quot;bbscc&quot; &quot;dd&quot; “”) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="String-Split-String-StringSplitOptions"><a href="#String-Split-String-StringSplitOptions" class="headerlink" title="String.Split(String[],StringSplitOptions)"></a>String.Split(String[],StringSplitOptions)</h3><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">string str &#x3D; &quot;aaatbbscctddt&quot;;

string []strArray &#x3D; str.Split(new String[]&#123;&quot;t&quot;,StringSplitOptions.RemoveEmptyEntries&#125;);&#x2F;&#x2F;去除空元素(result :&quot;aaa&quot; &quot;bbscc&quot; &quot;dd&quot;)

string []strArray &#x3D; str.Split(new String[]&#123;&quot;t&quot;,StringSplitOptions.None&#125;);&#x2F;&#x2F;保留空元素(result :&quot;aaa&quot; &quot;bbscc&quot; &quot;dd&quot; “”) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="String-Split-Char-Int32-StringSplitOptions"><a href="#String-Split-Char-Int32-StringSplitOptions" class="headerlink" title="String.Split(Char[],Int32,StringSplitOptions)"></a>String.Split(Char[],Int32,StringSplitOptions)</h3><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">string str &#x3D; &quot;aaatbbscctddt&quot;;

string []strArray &#x3D; str.Split(new char[]&#123;&#39;t&#39;,2,StringSplitOptions.RemoveEmptyEntries&#125;);&#x2F;&#x2F;切割成2份且去除空元素(result :&quot;aaa&quot; &quot;bbscctddt&quot;)

string []strArray &#x3D; str.Split(new char[]&#123;&#39;t&#39;,2,StringSplitOptions.None&#125;);&#x2F;&#x2F;切割成2份且保留空元素(result :&quot;aaa&quot; &quot;bbscctddt&quot; “”)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="String-Split-String-Int32-StringSplitOptions"><a href="#String-Split-String-Int32-StringSplitOptions" class="headerlink" title="String.Split(String[],Int32,StringSplitOptions)"></a>String.Split(String[],Int32,StringSplitOptions)</h3><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">string str &#x3D; &quot;aaatbbscctddt&quot;;

string []strArray &#x3D; str.Split(new String[]&#123;&quot;t&quot;,2,StringSplitOptions.RemoveEmptyEntries&#125;);&#x2F;&#x2F;切割成2份且去除空元素(result :&quot;aaa&quot; &quot;bbscctddt&quot;)

string []strArray &#x3D; str.Split(new String[]&#123;&quot;t&quot;,2,StringSplitOptions.None&#125;);&#x2F;&#x2F;切割成2份且保留空元素(result :&quot;aaa&quot; &quot;bbscctddt&quot; “”)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h2><p>正则匹配拆分字符串提供了5个重载函数:</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="http://blog.csdn.net/chen_zw/article/details/M_System_Text_RegularExpressions_Regex_Split_1_16219e3a.htm">Regex.Split (String)</a></td>
<td align="left">在由<a href="http://blog.csdn.net/chen_zw/article/details/T_System_Text_RegularExpressions_Regex.htm">Regex</a> 构造函数中指定的正则表达式模式定义的位置拆分指定的输入字符串。由 .NET Compact Framework 支持。</td>
</tr>
<tr>
<td align="left"><a href="http://blog.csdn.net/chen_zw/article/details/M_System_Text_RegularExpressions_Regex_Split_1_843a3b0f.htm">Regex.Split (String, Int32)</a></td>
<td align="left">在由 Regex 构造函数中指定的正则表达式定义的位置,将指定的输入字符串拆分指定的最大次数。由 .NET Compact Framework 支持。</td>
</tr>
<tr>
<td align="left"><a href="http://blog.csdn.net/chen_zw/article/details/M_System_Text_RegularExpressions_Regex_Split_1_d460c748.htm">Regex.Split (String, String)</a></td>
<td align="left">在由正则表达式模式定义的位置拆分输入字符串。由 .NET Compact Framework 支持。</td>
</tr>
<tr>
<td align="left"><a href="http://blog.csdn.net/chen_zw/article/details/M_System_Text_RegularExpressions_Regex_Split_1_1c9576da.htm">Regex.Split (String, Int32, Int32)</a></td>
<td align="left">从输入字符串中的指定字符位置开始,在由 Regex 构造函数中指定的正则表达式定义的位置,将指定的输入字符串拆分指定的最大次数。由 .NET Compact Framework 支持。</td>
</tr>
<tr>
<td align="left"><a href="http://blog.csdn.net/chen_zw/article/details/M_System_Text_RegularExpressions_Regex_Split_2_385f6254.htm">Regex.Split (String, String, RegexOptions)</a></td>
<td align="left">在由指定的正则表达式模式定义的位置拆分输入字符串。可指定选项来修改匹配的行为。</td>
</tr>
</tbody></table>
<h3 id="添加命名空间"><a href="#添加命名空间" class="headerlink" title="添加命名空间"></a>添加命名空间</h3><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System.Text.RegularExpressions;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="函数demo"><a href="#函数demo" class="headerlink" title="函数demo"></a>函数demo</h3><h4 id="Regex-Split-String-String"><a href="#Regex-Split-String-String" class="headerlink" title="Regex.Split(String,String)"></a>Regex.Split(String,String)</h4><p>string str &#x3D; “aaatsbbtscctsdd”;<br>stirng []strArray &#x3D; Regex.Split(str,”ts”); &#x2F;&#x2F;正则匹配切割(result: “aaa” “bb” “cc” “dd”);</p>
<h4 id="Regex-Split-String-String-1"><a href="#Regex-Split-String-String-1" class="headerlink" title="Regex.Split(String,String)"></a>Regex.Split(String,String)</h4><p>string str &#x3D; “aaatsbbtscctsdd”;<br>stirng []strArray &#x3D; Regex.Split(str,”ts”,RegexOptions.IgnoreCase); &#x2F;&#x2F;正则匹配切割(result: “aaa” “bb” “cc” “dd”);</p>
<h2 id="字符分割应用"><a href="#字符分割应用" class="headerlink" title="字符分割应用"></a>字符分割应用</h2><h3 id="单字符拆分"><a href="#单字符拆分" class="headerlink" title="单字符拆分"></a>单字符拆分</h3><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">string str &#x3D; &quot;aaatbbscctdd&quot;;

string []strArray &#x3D; str.Split(new char[]&#123;&#39;t&#39;&#125;); 或string []strArray &#x3D; str.Split(&#39;t&#39;); &#x2F;&#x2F;单字符切割(result : &quot;aaa&quot;  &quot;bbscc&quot;  &quot;dd&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="多字符拆分"><a href="#多字符拆分" class="headerlink" title="多字符拆分"></a>多字符拆分</h3><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">string str &#x3D; &quot;aaatbbscctdd&quot;;

string []strArray &#x3D; str.Split(new char[]&#123;&#39;t&#39;,&#39;s&#39;&#125;); &#x2F;&#x2F;多字节切割(result : &quot;aaa&quot; &quot;bb&quot; &quot;cc&quot; &quot;dd&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="字符串拆分"><a href="#字符串拆分" class="headerlink" title="字符串拆分"></a>字符串拆分</h3><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System.Text.RegularExpressions;

string str &#x3D; &quot;aaatsbbtscctsdd&quot;;

stirng []strArray &#x3D; Regex.Split(str,&quot;ts&quot;,RegexOptions.IgnoreCase); &#x2F;&#x2F;正则匹配切割且(result: &quot;aaa&quot; &quot;bb&quot; &quot;cc&quot; &quot;dd&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>或者</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">string str &#x3D; &quot;aaatsbbtscctsdd&quot;;

string []strArray &#x3D; str.Split(new string[]&#123;&quot;ts&quot;&#125;); &#x2F;&#x2F;字符串切割(result : &quot;aaa&quot; &quot;bb&quot; &quot;cc&quot; &quot;dd&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>String.Split方法没有重载String.Split(stirng [])方法,也就是说str.Split(“t”)或者str.Split(new string[]{“ts”,”dd”})都是错误的。</p>
<p>除了切割单字符可用String.Split(‘t’)外,其它的都必须用String.Split(new char[]{})这样的格式,否则编译会出错</p>
<h1 id="功能实现小记"><a href="#功能实现小记" class="headerlink" title="功能实现小记"></a>功能实现小记</h1><h2 id="WPF打开网页实现"><a href="#WPF打开网页实现" class="headerlink" title="WPF打开网页实现"></a>WPF打开网页实现</h2><h3 id="浏览器打开"><a href="#浏览器打开" class="headerlink" title="浏览器打开"></a>浏览器打开</h3><p>添加头文件引用</p>
<pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">using System.Diagnostics;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Process proc &#x3D; new System.Diagnostics.Process();
proc.StartInfo.FileName &#x3D; &quot;http:&#x2F;&#x2F;www.baidu.com&quot;;
proc.Start();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="WPF应用程序中打开"><a href="#WPF应用程序中打开" class="headerlink" title="WPF应用程序中打开"></a>WPF应用程序中打开</h3><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">WebBrowser wBrowser &#x3D; new WebBrowser();
wBrowser .Source &#x3D; new Uri(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;);     
this.Content &#x3D; wBrowser ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="WPF插入超链接"><a href="#WPF插入超链接" class="headerlink" title="WPF插入超链接"></a>WPF插入超链接</h2><p>前端XAML:<br>值得注意的一点是,超链接的文字一定要包含在&lt;hyperlink&gt;&lt;&#x2F;hyperlink&gt;标记中,否则报错。并且&lt;hyperlink&gt;&lt;&#x2F;hyperlink&gt;标记不可以单独出现,一定要嵌套在textblcok中</p>
<pre class="line-numbers language-xaml" data-language="xaml"><code class="language-xaml">&lt;TextBlock&gt;
        &lt;Hyperlink NavigateUri&#x3D;&quot;http:&#x2F;&#x2F;www.nlecloud.com&#x2F;my&#x2F;forget&quot; 
                   Click&#x3D;&quot;ForgotPassword_Click&quot;
                   Name&#x3D;&quot;ForgotPassword&quot;&gt;
          忘记密码
        &lt;&#x2F;Hyperlink&gt;
&lt;&#x2F;TextBlock&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>后端C#:</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void ForgotPassword_Click(object sender, RoutedEventArgs e)
        &#123;&#x2F;&#x2F;忘记密码
            Hyperlink link &#x3D; sender as Hyperlink;
            Process.Start(new ProcessStartInfo(link.NavigateUri.AbsoluteUri));
        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>坑:窗口全局的MoseMove事件会影响超链接标记的点击属性,导致超链接点击事件不发生的情况。</p>
<h2 id="实现Image控件点击事件"><a href="#实现Image控件点击事件" class="headerlink" title="实现Image控件点击事件"></a>实现Image控件点击事件</h2><p>为Image控件设置鼠标点击事件</p>
<pre class="line-numbers language-XAMl" data-language="XAMl"><code class="language-XAMl">&lt;Image
                            ToolTip&#x3D;&quot;进入新大陆物联网云&quot;
                            MouseLeftButtonDown&#x3D;&quot;Image_MouseLeftButtonDown&quot;
                            Width&#x3D;&quot;120&quot; Height&#x3D;&quot;50&quot;
                            &gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在后台代码中写出点击事件的逻辑实现</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void Image_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        &#123;
            Process proc &#x3D; new System.Diagnostics.Process();
            proc.StartInfo.FileName &#x3D; &quot;http:&#x2F;&#x2F;www.nlecloud.com&#x2F;&quot;;
            proc.Start();
        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="HeaderStringFormat-属性"><a href="#HeaderStringFormat-属性" class="headerlink" title="HeaderStringFormat 属性"></a>HeaderStringFormat 属性</h2><p>获取或设置一个撰写字符串,该字符串指定如果 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.headeredcontentcontrol.header?view=netcore-3.1#System_Windows_Controls_HeaderedContentControl_Header">Header</a> 属性显示为字符串,应如何设置该属性的格式。</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">[System.ComponentModel.Bindable(true)]
public string HeaderStringFormat &#123; get; set; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h4 id="属性值"><a href="#属性值" class="headerlink" title="属性值"></a>属性值</h4><ul>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.string?view=netcore-3.1">String</a><br>一个撰写字符串,指定如果 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.headeredcontentcontrol.header?view=netcore-3.1#System_Windows_Controls_HeaderedContentControl_Header">Header</a> 属性显示为字符串,应如何设置该属性的格式。 默认值为 <code>null</code>。</li>
<li>属性<br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.componentmodel.bindableattribute?view=netcore-3.1">BindableAttribute</a></li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>下面的示例将绑定 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.tabcontrol?view=netcore-3.1">TabControl</a> 到对象的集合 <code>Student</code> 。 <code>Student</code>类具有一个 <code>Name</code> 属性和一个对象的集合 <code>Course</code> ,并实现了 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.iformattable.tostring?view=netcore-3.1">IFormattable.ToString</a> 返回 <code>Name</code> 学生或列出学生课程的字符串的方法。 该示例使用将 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.headeredcontentcontrol.headerstringformat?view=netcore-3.1">HeaderStringFormat</a> 学生的名称放在 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.headeredcontentcontrol.header?view=netcore-3.1">Header</a> 从) 继承的每个 (的中 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.tabitem?view=netcore-3.1">TabItem</a> <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.headeredcontentcontrol?view=netcore-3.1">HeaderedContentControl</a> ,并使用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.tabcontrol.contentstringformat?view=netcore-3.1">TabControl.ContentStringFormat</a> 来为的内容中的每个学生显示课程列表 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.tabitem?view=netcore-3.1">TabItem</a> 。</p>
<pre class="line-numbers language-xaml" data-language="xaml"><code class="language-xaml">&lt;Grid&gt;
  &lt;Grid.Resources&gt;
    &lt;src:Students x:Key&#x3D;&quot;Students&quot;&#x2F;&gt;

    &lt;Style TargetType&#x3D;&quot;TabItem&quot;&gt;
      &lt;Setter Property&#x3D;&quot;HeaderStringFormat&quot; Value&#x3D;&quot;n&quot;&#x2F;&gt;
      &lt;Setter Property&#x3D;&quot;FontFamily&quot; Value&#x3D;&quot;Lucida Sans Unicode&quot;&#x2F;&gt;
      &lt;Setter Property&#x3D;&quot;Foreground&quot; Value&#x3D;&quot;Green&quot;&#x2F;&gt;
      &lt;Setter Property&#x3D;&quot;FontWeight&quot; Value&#x3D;&quot;Bold&quot;&#x2F;&gt;
    &lt;&#x2F;Style&gt;
  &lt;&#x2F;Grid.Resources&gt;

  &lt;TabControl ItemsSource&#x3D;&quot;&#123;StaticResource Students&#125;&quot;
              FontFamily&#x3D;&quot;Lucida Console&quot; Foreground&#x3D;&quot;Navy&quot;
              ContentStringFormat&#x3D;&quot;cl&quot;&#x2F;&gt;
&lt;&#x2F;Grid&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>下面的示例实现 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.iformattable.tostring?view=netcore-3.1">IFormattable.ToString</a> 方法以返回 <code>Name</code> 学生的或列出学生课程的字符串。</p>
<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> <span class="token function">ToString</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> format<span class="token punctuation">,</span> <span class="token class-name">IFormatProvider</span> formatProvider<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 'n': print the name only.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>format <span class="token operator">==</span> <span class="token string">"n"</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> Name<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 'cl': print the course list.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>format <span class="token operator">==</span> <span class="token string">"cl"</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token class-name"><span class="token keyword">string</span></span> stringFormat <span class="token operator">=</span> <span class="token string">"&#123;0,-25&#125;&#123;1,-30&#125;&#123;2,-10&#125;\r\n"</span><span class="token punctuation">;</span>

        <span class="token class-name">StringBuilder</span> str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        str<span class="token punctuation">.</span><span class="token function">AppendLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        str<span class="token punctuation">.</span><span class="token function">AppendFormat</span><span class="token punctuation">(</span>stringFormat<span class="token punctuation">,</span> <span class="token string">"Title"</span><span class="token punctuation">,</span> <span class="token string">"Description"</span><span class="token punctuation">,</span> <span class="token string">"ID"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        str<span class="token punctuation">.</span><span class="token function">AppendLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

        <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token class-name">Course</span> c <span class="token keyword">in</span> Courses<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            str<span class="token punctuation">.</span><span class="token function">AppendFormat</span><span class="token punctuation">(</span>stringFormat<span class="token punctuation">,</span> c<span class="token punctuation">.</span>Title<span class="token punctuation">,</span> c<span class="token punctuation">.</span>Description<span class="token punctuation">,</span> c<span class="token punctuation">.</span>SectionID<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.headeredcontentcontrol.headerstringformat?view=netcore-3.1">HeaderStringFormat</a> 可以是预定义的复合字符串格式。 有关字符串格式的详细信息,请参阅 <a href="https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/formatting-types">格式设置类型</a>。 如果设置 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.headeredcontentcontrol.headertemplate?view=netcore-3.1">HeaderTemplate</a> 了或的 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.headeredcontentcontrol.headertemplateselector?view=netcore-3.1">HeaderTemplateSelector</a> 属性,则将 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.headeredcontentcontrol?view=netcore-3.1">HeaderedContentControl</a> <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.headeredcontentcontrol.headerstringformat?view=netcore-3.1">HeaderStringFormat</a> 忽略属性。</p>
<h3 id="依赖项属性信息"><a href="#依赖项属性信息" class="headerlink" title="依赖项属性信息"></a>依赖项属性信息</h3><table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">标识符字段</td>
<td align="left"><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.headeredcontentcontrol.headerstringformatproperty?view=netcore-3.1">HeaderStringFormatProperty</a></td>
</tr>
<tr>
<td align="left">元数据属性设置为<code>true</code></td>
<td align="left">无</td>
</tr>
</tbody></table>
<h2 id="Xaml控件不可用属性"><a href="#Xaml控件不可用属性" class="headerlink" title="Xaml控件不可用属性"></a>Xaml控件不可用属性</h2><pre class="line-numbers language-xaml" data-language="xaml"><code class="language-xaml">isEnable &#x3D; &quot;False&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="登录文本框判空提示"><a href="#登录文本框判空提示" class="headerlink" title="登录文本框判空提示"></a>登录文本框判空提示</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">getUsername.text &#x3D;&#x3D; null;

getPassword.password &#x3D;&#x3D; null;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="ToolTip提示控件"><a href="#ToolTip提示控件" class="headerlink" title="ToolTip提示控件"></a>ToolTip提示控件</h2><p>ToolTip控件可以在鼠标移动到某控件上后弹出提示的控件</p>
<pre class="line-numbers language-xaml" data-language="xaml"><code class="language-xaml">&lt; Button Content &#x3D;&quot;Button&quot; HorizontalAlignment &#x3D;&quot;Left&quot; Margin &#x3D;&quot;80,58,0,0&quot; VerticalAlignment &#x3D;&quot;Top&quot; Width &#x3D;&quot;75&quot;&gt;
           &lt; Button.ToolTip &gt;
               &lt; ToolTip Placement &#x3D;&quot;Right&quot;&gt;
                   &lt; TextBlock &gt;
                   按钮tooltip
                   &lt;&#x2F; TextBlock &gt;
               &lt;&#x2F; ToolTip &gt;              
           &lt;&#x2F; Button.ToolTip &gt;
       &lt;&#x2F; Button &gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>其中Placement用来确定Tooltip提示框出现的位置。</p>
<p>对于StackPanel的控件,如下所示:</p>
<pre class="line-numbers language-xaml" data-language="xaml"><code class="language-xaml">&lt; StackPanel.ToolTip &gt;
  &lt; ToolTip Placement &#x3D;&quot;Center&quot;&gt;
 	 &lt; TextBlock &gt; 
 		 第一个按钮 
 	 &lt;&#x2F; TextBlock &gt;
  &lt;&#x2F; ToolTip &gt;
&lt;&#x2F; StackPanel.ToolTip &gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对于ToolTip的控制,还提供了ToolTipService类,ToolTipService是一个静态类,表示一个服务,该服务提供用于控制提示的显示和行为的属性和事件。</p>
<pre class="line-numbers language-xaml" data-language="xaml"><code class="language-xaml">&lt; Button ToolTipService.Placement &#x3D;&quot;Center&quot; ToolTipService.BetweenShowDelay &#x3D;&quot;1000&quot; ToolTipService.ToolTip &#x3D;&quot;按钮提示&quot;  Content &#x3D;&quot;Button&quot; HorizontalAlignment &#x3D;&quot;Left&quot; Margin &#x3D;&quot;80,58,0,0&quot; VerticalAlignment &#x3D;&quot;Top&quot; Width &#x3D;&quot;75&quot;&gt;
	&lt; Button.ToolTip &gt;
		&lt; ToolTip Placement &#x3D;&quot;Right&quot;&gt;
			&lt; TextBlock &gt;
 				按钮tooltip
			&lt;&#x2F; TextBlock &gt;
		&lt;&#x2F; ToolTip &gt;
	&lt;&#x2F; Button.ToolTip &gt;
&lt;&#x2F; Button &gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>ToolTipService主要属性</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">ToolTipService.InitialShowDelay&#x3D;&quot;1000&quot;  &#x2F;&#x2F;获取或设置工具提示打开前的时间长度

ToolTipService.ShowDuration&#x3D;&quot;7000&quot; &#x2F;&#x2F;显示时间

ToolTipService.BetweenShowDelay&#x3D;&quot;2000&quot;&#x2F;&#x2F;获取或设置两个工具提示显示之间的最大时间(第二个工具提示不经延迟即会出现)。

ToolTipService.Placement&#x3D;&quot;Right&quot;&#x2F;&#x2F;工具提示相对原控件打开时的方向,并指定工具提示在与屏幕边界重叠时的行为。

ToolTipService.PlacementRectangle&#x3D;&quot;50,0,0,0&quot;&#x2F;&#x2F;获取或设置相对于其来放置工具提示的矩形区域。

ToolTipService.HorizontalOffset&#x3D;&quot;10&quot;&#x2F;&#x2F;获取或设置由 PlacementRectangle 和 PlacementTarget 属性为工具提示指定的区域的左侧偏移量。

ToolTipService.VerticalOffset&#x3D;&quot;20&quot;&#x2F;&#x2F;获取或设置由 PlacementRectangle 和 PlacementTarget 属性为工具提示指定的区域的顶部距离。

ToolTipService.HasDropShadow&#x3D;&quot;False&quot;&#x2F;&#x2F;获取或设置工具提示是否显示投影效果。

ToolTipService.IsEnabled&#x3D;&quot;True&quot;&#x2F;&#x2F;获取或设置是否显示工具提示。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="DispatcherTimer线程"><a href="#DispatcherTimer线程" class="headerlink" title="DispatcherTimer线程"></a>DispatcherTimer线程</h2><p>什么是 DispatcherTimer? DispatcherTimer是一种定时器!</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public MainWindow()
&#123;
    InitializeComponent();
    this.Loaded +&#x3D; MainWindow_Loaded;


&#125;
DispatcherTimer time;&#x2F;&#x2F;实例化一个定时器
      
void MainWindow_Loaded(object sender,RoutedEventArgs e)
&#123;
    time &#x3D; new DispatcherTimer();
    time.Interval &#x3D; TimeSpan.FromSeconds(3000);
    time.Tick +&#x3D; time_tick;
    time.Start();

&#125;
void time_tick (object sender,EventArgs e)
&#123;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="WPF窗体出现位置"><a href="#WPF窗体出现位置" class="headerlink" title="WPF窗体出现位置"></a>WPF窗体出现位置</h2><p>如何设置WPF窗体在屏幕上显示的位置?</p>
<p>方法一<br>在后台代码中添加</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public Login()
&#123;
InitializeComponent();
WindowStartupLocation &#x3D; WindowStartupLocation.CenterScreen;&#x2F;&#x2F;WPF窗体在屏幕上居中
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>方法二<br>在XAML代码中添加</p>
<pre class="line-numbers language-xaml" data-language="xaml"><code class="language-xaml">WindowStartupLocation&#x3D;&quot;CenterScreen&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="获取当前桌面路径"><a href="#获取当前桌面路径" class="headerlink" title="获取当前桌面路径"></a>获取当前桌面路径</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">string strDesktopPath &#x3D; Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory);&#x2F;&#x2F;用函数获取当前电脑的桌面路径保存为string类型的变量<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="WPF窗体无边框"><a href="#WPF窗体无边框" class="headerlink" title="WPF窗体无边框"></a>WPF窗体无边框</h2><p>WPF做这样的窗口非常简单,只有需在窗口设计中设置两个属性,一个是AllowsTransparency, 设置为 Ture;  一个是 WindowStyle, 设置为 None。<br><img src="https://i.loli.net/2020/10/19/mnHiBZf5DvaSx2X.png" alt="属性设置"><br>注:是Window的属性,不要选中其他的控件。</p>
<p>另外,如果AllowsTransparency&#x3D;”True”,那么 WindowStyle只能为 None, VS2015 已经做到连动设置,只要勾选AllowsTransparency,后一个也跟着变了。但 VS2008 还是需要用户分别设置,不然会报错。</p>
<p>还有一个问题不得不提,AllowsTransparency&#x3D;”True” 之后就无法使用 WindowsFormsHost控件了,因为就算用了,WFH里的任何控件也是透明无法显示出来的,比如ReportViewer</p>
<h2 id="WPF窗体拖动"><a href="#WPF窗体拖动" class="headerlink" title="WPF窗体拖动"></a>WPF窗体拖动</h2><p>标题栏上有最大化最小化和关闭的按钮,其中在登录窗口我们一般是不会使用最大化按钮的。可是不得不说,标题栏还有一个很实用的作用,就是可以拖拽整个窗口,用户只要单击标题栏不放,就可以拖到桌面的任何地方。如今把标题栏隐藏之后,该如何弥补呢?</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void Window_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        &#123;
            try
            &#123;
                this.DragMove();
            &#125;
            catch &#123; &#125;
        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>网上很多教程到这一步就结束了,对我这种没有精通C#的人来说很不友善,实际上还需要为窗体XAML添加一个事件,代码如下,其他有关窗体操作的内容以此类推:</p>
<pre class="line-numbers language-xaml" data-language="xaml"><code class="language-xaml">MouseMove&#x3D;&quot;Window_MouseLeftButtonDown&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>注:网上有些示例里,没有用 try{}catch{},而只有一行代码</p>
<pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">this.DragMove();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果在登录窗口,只有那么几个控件和事件的话,应该也是无大碍的。</p>
<p>在这里有个小小的经验必须分享一下:由于在主界面里也使用了这种无标题栏的窗口,鼠标在Gridview上操作时,经常会引发异常崩溃。所以最好加 try…catch… 避免异常,哪怕是登录窗口也不例外。</p>
<h3 id="设置允许拖动区域"><a href="#设置允许拖动区域" class="headerlink" title="设置允许拖动区域"></a>设置允许拖动区域</h3><p>这里遇到一点问题,当窗体中有RichTextBox这种能输入的控件时,在控件中按下左键拖动鼠标就会报错,估计是控件本身的鼠标拖动和窗体的冲突。再者,我们在这些控件中拖动鼠标的目的是选择文字,而不是拖动窗口,这时就需要设置相应区域:</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void BackGround_MouseMove(object sender, MouseEventArgs e)
    &#123;
      Point pp &#x3D; Mouse.GetPosition(this);
      if (pp.X &gt;&#x3D; 20 &amp;&amp; pp.X &lt;&#x3D; 288 &amp;&amp; pp.Y&gt;&#x3D;78 &amp;&amp; pp.Y &lt;&#x3D; 460)
      	&#123;
    
      	&#125;
      else
      &#123;
        if (e.LeftButton &#x3D;&#x3D; MouseButtonState.Pressed)
        &#123;
          &#x2F;&#x2F;this.DragMove();     
          Window.DragMove();
        &#125;
      &#125;
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="输入密码回车登录"><a href="#输入密码回车登录" class="headerlink" title="输入密码回车登录"></a>输入密码回车登录</h2><p>很多网站会注意这种情况,输入密码后回车,系统就可以登录,这就是良好的用户体验。(当然,也有些网站不注意用户体验,用户必须用鼠标去点击登录的)</p>
<p>其实在密码框添加一个 KeyDown 事件就可以</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void txt_Pwd_KeyDown(object sender, KeyEventArgs e)
&#123;
    switch (e.Key)
    &#123;
        case Key.Enter:
            btn_login_Click(btn_login, null);
            break;

        default:
            break;
    &#125;
&#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>同时需要在Xaml文件中添加键盘点击事件名称声明:</p>
<pre class="line-numbers language-xaml" data-language="xaml"><code class="language-xaml">Keyboard.KeyDown&#x3D;&quot;txt_Pwd_KeyDown&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="WPF退出程序"><a href="#WPF退出程序" class="headerlink" title="WPF退出程序"></a>WPF退出程序</h2><p>当处于全屏模式下时,没有右上角的退出按钮,此时需要手动写button退出功能。<br>调用下面语句可以直接退出。</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Application.Current.Shutdown();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h1 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h1><h2 id="HandyControl与LiveCharts使用出现图形位置偏移问题"><a href="#HandyControl与LiveCharts使用出现图形位置偏移问题" class="headerlink" title="HandyControl与LiveCharts使用出现图形位置偏移问题"></a><a href="https://www.cnblogs.com/guanguanchangyu/p/12604090.html">HandyControl与LiveCharts使用出现图形位置偏移问题</a></h2><blockquote>
<p><code>HandyControl</code>是一套<code>WPF</code>控件库,它几乎重写了所有原生样式,同时包含70余款自定义控件(正逐步增加)。</p>
</blockquote>
<p>此处为<a href="https://github.com/HandyOrg/HandyControl"><code>HandyControl</code>源码传送门</a>,希望能对它能有所了解</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>由于<code>HandyControl</code>作为<code>WPF</code>的一款<code>UI</code>库,暂时没有考虑过增加,数据图形控件,对于需要数据统计图形展示的用户,可能引入<code>LiveCharts</code>做数据展示处理,运行之后,出现之前好好的控件,显示效果中,图形位置偏移走样问题。</p>
<h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a><a href="https://www.cnblogs.com/guanguanchangyu/p/12604090.html#1527470209">现象</a></h3><p>引用<code>HandyControl</code>前,感觉生活很美好</p>
<p><a href="https://file.budbud.cn/handycontrol/path/livechart-right.png"><img src="https://file.budbud.cn/handycontrol/path/livechart-right.png" alt="livechart-right"></a></p>
<p>引入<code>HandyControl</code>后,世界都懵逼了</p>
<p><a href="https://file.budbud.cn/handycontrol/path/livechart-wrong.png"><img src="https://file.budbud.cn/handycontrol/path/livechart-wrong.png" alt="livechart-wrong"></a></p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>由于<code>HandyControl</code>本身重写了几乎所有的原生样式,当然也包括了<code>Path</code>的默认样式,<a href="https://github.com/HandyOrg/HandyControl/blob/28c464a8e2bc5318f3957a41dae799b824554232/src/Shared/HandyControl_Shared/Themes/Basic/Paths.xaml">详细修改处👉传送门</a></p>
<pre class="line-numbers language-xaml" data-language="xaml"><code class="language-xaml">&lt;Style TargetType&#x3D;&quot;Path&quot;&gt;
        &lt;Setter Property&#x3D;&quot;Stretch&quot; Value&#x3D;&quot;Uniform&quot;&#x2F;&gt;
&lt;&#x2F;Style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>清除<code>HandyControl</code>影响,设置<code>Path</code>的<code>Style</code>为空,引入位置,一般在<code>App.xaml</code>中或者使用<code>LiveCharts</code>控件的<code>父级资源</code>中</p>
<pre class="line-numbers language-xaml" data-language="xaml"><code class="language-xaml">&lt;Style TargetType&#x3D;&quot;Path&quot; BasedOn&#x3D;&quot;&#123;x:Null&#125;&quot;&#x2F;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>解决方案出处:<a href="https://www.cnblogs.com/guanguanchangyu/p/12604090.html">https://www.cnblogs.com/guanguanchangyu/p/12604090.html</a></p>
<h1 id="错误error"><a href="#错误error" class="headerlink" title="错误error"></a>错误error</h1><h2 id="未将对象引用设置到对象的实例"><a href="#未将对象引用设置到对象的实例" class="headerlink" title="未将对象引用设置到对象的实例"></a>未将对象引用设置到对象的实例</h2><p>完整错误:System.NullReferenceException:未将对象引用设置到对象的实例</p>
<p>错误场景:</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public static int numberPeople()
       &#123;&#x2F;&#x2F;当前排队人数
           SensorDataFuzzyQryPagingParas query &#x3D; new SensorDataFuzzyQryPagingParas()
           &#123;
               DeviceID&#x3D;119374,
               ApiTags &#x3D; &quot;number_up&quot;
           &#125;;
           var yxh &#x3D; SDK.GetSensorDatas(query, TempInfo.API_HOST);
 		   &#x2F;*
   		 修改前
   		 return yxh.ResultObj.count;
   	 *&#x2F;
           if(yxh.IsSuccess())
           &#123;
               return yxh.ResultObj.Count;
           &#125;
           else
           &#123;
               return 0;
           &#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>错误原因:出现这个问题是因为引用的对象是null或empty导致</p>
<p>声明变量时:T t &#x3D; null;(T为类名),此时在栈上有一个地址。地址占4个字节,但地址没有任何指向,即指向内容为空。如果调用T的成员函数,出错:未将对象引用设置到对象实例</p>
<h2 id="不能在变量声明中指定数组大小"><a href="#不能在变量声明中指定数组大小" class="headerlink" title="不能在变量声明中指定数组大小"></a>不能在变量声明中指定数组大小</h2><p>不能在变量声明中指定数组大小(请尝试使用“new”表达式初始化)</p>
<p>将大小指定为数组声明的一部分时会发生此错误。 若要解决此错误,请使用 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/new-operator">new 运算符</a>表达式。</p>
<p>下面的示例生成 CS0270:</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">&#x2F;&#x2F; CS0270.cs  
&#x2F;&#x2F; compile with: &#x2F;t:module  
  
public class Test  
&#123;  
   int[10] a;   &#x2F;&#x2F; CS0270  
   &#x2F;&#x2F; To resolve, use the following line instead:  
   &#x2F;&#x2F; int[] a &#x3D; new int[10];  
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="动态图表LiveCharts"><a href="#动态图表LiveCharts" class="headerlink" title="动态图表LiveCharts"></a>动态图表LiveCharts</h1><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p>基本图表图线建立:<a href="http://www.manongjc.com/detail/14-bpxrwoalubxfjxk.html">http://www.manongjc.com/detail/14-bpxrwoalubxfjxk.html</a></p>
<p>基本图形的数据绑定:<a href="https://www.liangzl.com/get-article-detail-172477.html">https://www.liangzl.com/get-article-detail-172477.html</a></p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">mychart.Series &#x3D; new SeriesCollection
           &#123;
               new LineSeries
               &#123;
                   Values &#x3D; new ChartValues&lt;int&gt;(temp),
                   DataLabels&#x3D;true,
                   Title &#x3D; &quot;当前人数&quot;
               &#125;
             
           &#125;;

           &#x2F;&#x2F;myAxisX.Labels &#x3D; new[] &#123; &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot; &#125;;&#x2F;&#x2F;横坐标定义
           DateTime now &#x3D; new DateTime();

           for (int j &#x3D; 0; j &lt; 10; j++)
           &#123;
               time1[j] &#x3D; now.ToString();

           &#125;
           myAxisX.Labels &#x3D; time1;
           myAxisY.MaxValue &#x3D; 10;&#x2F;&#x2F;纵坐标最大值定义
           &#x2F;&#x2F;myAxisY.LabelFormatter &#x3D; value &#x3D;&gt; value.ToString(&quot;0%&quot;);
           myAxisY.Title &#x3D; &quot;人数&quot;;&#x2F;&#x2F;纵坐标标题<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="设置曲线"><a href="#设置曲线" class="headerlink" title="设置曲线"></a>设置曲线</h2><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">LineSeries mylineseries &#x3D; new LineSeries();&#x2F;&#x2F;首先实例化一条折线

mylineseries.Title &#x3D; &quot;night&quot;;&#x2F;&#x2F;设置折线名称

mylineseries.Stroke &#x3D; System.Windows.Media.Brushes.Black;&#x2F;&#x2F;设置折线颜色

mylineseries.StrokeThickness &#x3D; 10;&#x2F;&#x2F;设置折线粗细

mylineseries.StrokeDashArray &#x3D; new System.Windows.Media.DoubleCollection &#123; 2 &#125;;&#x2F;&#x2F;设置折线样式

mylineseries.LineSmoothness &#x3D; 1;&#x2F;&#x2F;设置折线是否光滑

mylineseries.Fill &#x3D; System.Windows.Media.Brushes.LightBlue;&#x2F;&#x2F;设置折线填充颜色<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="设置图表"><a href="#设置图表" class="headerlink" title="设置图表"></a>设置图表</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">&lt;lvc:CartesianChart x:Name&#x3D;&quot;mychart&quot; Series&#x3D;&quot;&#123;Binding SeriesCollection&#125;&quot;&#x2F; &gt;&#x2F;&#x2F;首先在前台给图表命名

mychart.Background &#x3D; System.Windows.Media.Brushes.Gray;&#x2F;&#x2F;设置图表的背景颜色

mychart.LegendLocation &#x3D; LegendLocation.Top;&#x2F;&#x2F;设置图示位置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="设置轴线"><a href="#设置轴线" class="headerlink" title="设置轴线"></a>设置轴线</h2><pre class="line-numbers language-xaml" data-language="xaml"><code class="language-xaml">&#x2F;&#x2F;首先在前台对轴线命名
&lt;lvc:CartesianChart.AxisX&gt;  
&lt;lvc:Axis x:Name&#x3D;&quot;myaxisx&quot;&#x2F;&gt;  
&lt;&#x2F;lvc:CartesianChart.AxisX&gt;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">myaxisx.Separator.StrokeThickness &#x3D; 10;&#x2F;&#x2F;设置轴线粗细

myaxisx.Separator.Step &#x3D; 0.5;&#x2F;&#x2F;设置轴线间隔

myaxisx.Title &#x3D; &quot;Date&quot;;&#x2F;&#x2F;设置轴线标题

myaxisx.Position &#x3D; AxisPosition.RightTop;&#x2F;&#x2F;设置轴线标题

myaxisx.Labels &#x3D; new[]&#123; &quot;Mon&quot;, &quot;Tue&quot;,&quot;Wen&quot;,&quot;Thu&quot;,&quot;Fri&quot;,&quot;Sat&quot;,&quot;Sun&quot;&#125;;&#x2F;&#x2F;设置坐标轴标签

myaxisx.LabelsRotation &#x3D; 45;&#x2F;&#x2F;设置坐标轴标签旋转角度<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="设置提示"><a href="#设置提示" class="headerlink" title="设置提示"></a>设置提示</h2><pre class="line-numbers language-xaml" data-language="xaml"><code class="language-xaml">&#x2F;&#x2F;首先在前台对提示命名
&lt;lvc:CartesianChart.DataTooltip&gt;  
&lt;lvc:DefaultTooltip x:Name&#x3D;&quot;mytooltip&quot;&#x2F;&gt;  
&lt;&#x2F;lvc:CartesianChart.DataTooltip&gt;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">mytooltip.Background &#x3D; System.Windows.Media.Brushes.LightCyan;&#x2F;&#x2F;设置提示的背景颜色

mytooltip.SelectionMode &#x3D; TooltipSelectionMode.OnlySender;&#x2F;&#x2F;设置提示的选择模式

mytooltip.CornerRadius &#x3D; new CornerRadius(5);&#x2F;&#x2F;设置提示框的圆角半径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">&#x2F;&#x2F;设置提示框的边框颜色和大小
mytooltip.BorderBrush &#x3D; System.Windows.Media.Brushes.Yellow ;  
mytooltip.BorderThickness &#x3D; new Thickness (2);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>以上所有后台代码设置均可以在前台实现同样的设置<br>部分前台设置如下:</p>
<pre class="line-numbers language-xaml" data-language="xaml"><code class="language-xaml">&lt;lvc:CartesianChart.AxisY&gt; 
&lt;lvc:Axis Title&#x3D;&quot;star&quot; LabelFormatter&#x3D;&quot;&#123;Binding Formatter&#125;&quot; &gt;&lt;&#x2F;lvc:Axis&gt; 
&lt;&#x2F;lvc:CartesianChart.AxisY&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre class="line-numbers language-xaml" data-language="xaml"><code class="language-xaml">&lt;Window x:Class&#x3D;&quot;chart_line.MainWindow&quot;
xmlns&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;winfx&#x2F;2006&#x2F;xaml&#x2F;presentation&quot;
xmlns:x&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;winfx&#x2F;2006&#x2F;xaml&quot;
xmlns:d&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;expression&#x2F;blend&#x2F;2008&quot;
xmlns:mc&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;markup-compatibility&#x2F;2006&quot;
xmlns:local&#x3D;&quot;clr-namespace:chart_line&quot;
xmlns:lvc&#x3D;&quot;clr-namespace:LiveCharts.Wpf;assembly&#x3D;LiveCharts.Wpf&quot;
mc:Ignorable&#x3D;&quot;d&quot;
Title&#x3D;&quot;MainWindow&quot; Height&#x3D;&quot;350&quot; Width&#x3D;&quot;525&quot;&gt;
&lt;Grid x:Name&#x3D;&quot;grid&quot;&gt;
&lt;lvc:CartesianChart x:Name&#x3D;&quot;mychart&quot; Series&#x3D;&quot;&#123;Binding SeriesCollection&#125;&quot; &gt;
&lt;lvc:CartesianChart.AxisX&gt;
&lt;lvc:Axis x:Name&#x3D;&quot;myaxisx&quot;&#x2F;&gt;
&lt;&#x2F;lvc:CartesianChart.AxisX&gt;&lt;lvc:CartesianChart.AxisY&gt;
&lt;lvc:Axis Title&#x3D;&quot;star&quot; LabelFormatter&#x3D;&quot;&#123;Binding Formatter&#125;&quot; &gt;&lt;&#x2F;lvc:Axis&gt;
&lt;&#x2F;lvc:CartesianChart.AxisY&gt;
&lt;lvc:CartesianChart.DataTooltip&gt;
&lt;lvc:DefaultTooltip x:Name&#x3D;&quot;mytooltip&quot;  &#x2F;&gt;
&lt;&#x2F;lvc:CartesianChart.DataTooltip&gt;
&lt;&#x2F;lvc:CartesianChart&gt;
&lt;&#x2F;Grid&gt;
&lt;&#x2F;Window&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using LiveCharts;
using LiveCharts.Wpf;

namespace chart_line
&#123;
&#x2F;&#x2F;&#x2F; &lt;summary&gt;
&#x2F;&#x2F;&#x2F; Interaction logic for MainWindow.xaml
&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;
public partial class MainWindow : Window
&#123;
public SeriesCollection SeriesCollection &#123; get; set; &#125;
public Func&lt;double, string&gt; Formatter &#123; get; set; &#125;
public MainWindow()
&#123;
InitializeComponent();
LineSeries mylineseries &#x3D; new LineSeries();
mylineseries.Title &#x3D; &quot;night&quot;;mylineseries.Stroke &#x3D; System.Windows.Media.Brushes.Blue ;
mylineseries.StrokeThickness &#x3D; 10;mylineseries.StrokeDashArray &#x3D; new System.Windows.Media.DoubleCollection &#123; 2 &#125;;
mylineseries.LineSmoothness &#x3D; 1;mylineseries.Fill &#x3D; System.Windows.Media.Brushes.LightBlue  ;&#x2F;&#x2F;mylineseries.PointGeometry &#x3D; null;

mychart.LegendLocation &#x3D; LegendLocation.Top ;mychart.Background &#x3D; System.Windows.Media.Brushes.Gray ;
myaxisx.Separator.StrokeThickness &#x3D; 10;myaxisx.Separator.Stroke&#x3D; System.Windows.Media.Brushes.Red;
myaxisx.Separator.Step &#x3D; 0.5;myaxisx.Title &#x3D; &quot;Date&quot;;myaxisx.Position &#x3D; AxisPosition.RightTop;&#x2F;&#x2F;myaxisx.IsMerged &#x3D; true;

myaxisx.LabelsRotation &#x3D; 45;myaxisx.Labels &#x3D; new[]&#123; &quot;Mon&quot;, &quot;Tue&quot;,&quot;Wen&quot;,&quot;Thu&quot;,&quot;Fri&quot;,&quot;Sat&quot;,&quot;Sun&quot;&#125;;
&#x2F;&#x2F;mytooltip.BulletSize &#x3D; 10;
mytooltip.Background &#x3D; System.Windows.Media.Brushes.LightCyan  ;
mytooltip.SelectionMode &#x3D; TooltipSelectionMode.OnlySender;mytooltip.CornerRadius &#x3D; new CornerRadius(5);mytooltip.BorderBrush &#x3D; System.Windows.Media.Brushes.Yellow ;
mytooltip.BorderThickness &#x3D; new Thickness (2);
double[] mynum &#x3D; &#123; 1, 3, 1, 6, 2, 9, 4 &#125;;
mylineseries.Values &#x3D; new ChartValues&lt;double&gt; ( mynum );
Formatter &#x3D; value &#x3D;&gt; value + &quot;-N&quot;;
SeriesCollection &#x3D; new SeriesCollection &#123;mylineseries&#125;;

DataContext &#x3D; this;
&#125;
&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://img-blog.csdnimg.cn/20190124225942411.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIzMTc2MTMz,size_16,color_FFFFFF,t_70" alt="效果图"></p>
<h1 id="XAML"><a href="#XAML" class="headerlink" title="XAML"></a>XAML</h1><p>作为XAML语言的一条规则,必须完全在该对象元素上的任何其他属性元素之前或之后完全指定XAML内容属性的值。例如,以下标记不会编译。</p>
<pre class="line-numbers language-xaml" data-language="xaml"><code class="language-xaml">&lt;Button&gt;I am a
  &lt;Button.Background&gt;Blue&lt;&#x2F;Button.Background&gt;
  blue button&lt;&#x2F;Button&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h1 id="WPF控件"><a href="#WPF控件" class="headerlink" title="WPF控件"></a>WPF控件</h1><h2 id="Slider"><a href="#Slider" class="headerlink" title="Slider"></a><a href="https://www.cnblogs.com/Fred1987/p/6038608.html">Slider</a></h2><h3 id="设置整数"><a href="#设置整数" class="headerlink" title="设置整数"></a>设置整数</h3><p>这个控件上值默认是浮点数,改变它的值可以拖动滑块,也可以在具有焦点的时候使用键盘,还可以点击滑块两侧的空白处(类似滚动条),值的步进有两个属性控制LargeChange和SmallChange,默认值分别是1和0.1,所以会出现1.3543这种情况,不过完全可以自定义的,添加代码:</p>
<pre class="line-numbers language-xaml" data-language="xaml"><code class="language-xaml">Ticks&#x3D;&quot;1 2 3 4 5&quot; &#x2F;&#x2F;这个就是步进值的设置
IsSnapToTickEnabled&#x3D;&quot;True&quot; &#x2F;&#x2F;还要加上这一句才有效果<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>或者</p>
<pre class="line-numbers language-xaml" data-language="xaml"><code class="language-xaml">SmallChange&#x3D;&quot;1&quot; 
IsSnapToTickEnabled&#x3D;&quot;True&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="Border"><a href="#Border" class="headerlink" title="Border"></a>Border</h2><p>border作边框使用</p>
<pre class="line-numbers language-xaml" data-language="xaml"><code class="language-xaml">BorderBrush&#x3D;&quot;Black&quot;&#x2F;&#x2F;设置边框颜色
BorderThickness&#x3D;&quot;2&quot;&#x2F;&#x2F;设置边框粗细<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="TextBlock"><a href="#TextBlock" class="headerlink" title="TextBlock"></a>TextBlock</h2><h3 id="TextBlock换行"><a href="#TextBlock换行" class="headerlink" title="TextBlock换行"></a><a href="https://www.cnblogs.com/wuzhenyi/archive/2013/01/13/2858797.html">TextBlock换行</a></h3><p>新建一个TextBlock作为最基础的一个控件,他所携带的功能相对于其他的控件要来的比较少,</p>
<p>比较值得关注的属性出了布局用的以外和数据绑定意外,就只剩下的Text属性来。</p>
<p>TextBlock的默认内容属性是Text。</p>
<p>对于换行来说,需要关注的也就是Text和Inline2个属性。</p>
<p>常见的TextBlock换行方法</p>
<p>1)转义字符换行</p>
<p>在XAML的后台文件中加入代码</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Me.TextBlock1.Text &#x3D; &quot;AAAAAAA &quot; + vbCrLf + &quot;BBBBBBBB&quot;
this.TextBlock1.Text &#x3D; &quot;AAAAAAA\nBBBBBBBB&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>在XAML上写时</p>
<pre class="line-numbers language-xaml" data-language="xaml"><code class="language-xaml">&lt;TextBlock Text&#x3D;&quot;AAAAAAA
BBBBBB&quot;   Height&#x3D;&quot;198&quot; HorizontalAlignment&#x3D;&quot;Left&quot; 
           Margin&#x3D;&quot;30,27,0,0&quot; Name&#x3D;&quot;TextBlock1&quot; VerticalAlignment&#x3D;&quot;Top&quot; Width&#x3D;&quot;436&quot; &gt;       	&lt;&#x2F;TextBlock&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>这样就可以表示显示的表示换行了,</p>
<p>但是下面这种情况是无效的。</p>
<pre class="line-numbers language-xaml" data-language="xaml"><code class="language-xaml">        &lt;TextBlock  Height&#x3D;&quot;198&quot; HorizontalAlignment&#x3D;&quot;Left&quot; 
                   Margin&#x3D;&quot;30,27,0,0&quot; Name&#x3D;&quot;TextBlock1&quot; VerticalAlignment&#x3D;&quot;Top&quot; Width&#x3D;&quot;436&quot; &gt; 
            AAAAAAA
BBBBBB
        &lt;&#x2F;TextBlock&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在Text的内容里赋值时候,会按照XML去解析,所以对于XML的转义字符都会起到他们的作用,而上面这种情况,虽然这种写法是</p>
<p>是默认获取TextBlock的内容属性,但是在赋值过程中会经过Convert按照String来处理,字符串中解析到换行符时,默认转成了空格。</p>
<p>所以你看到的结果AAAAAAA和BBBBBB并没有被换行表示,只是中间隔了一个空格。</p>
<p>另外XML的转义字符:</p>
<p><strong>空格</strong> (&amp;#x0020;)<br>Tab (&amp;#x0009;)<br><strong>回车</strong> (&amp;#x000D;)<br><strong>换行</strong> (&amp;#x000A;)</p>
<p>2)设置属性,自动换行</p>
<p>因为TextBlock有TextWrapping属性的支持,根据控件宽度自动设置换行,没有特殊要求的时候,这基本上能满足需求</p>
<pre class="line-numbers language-xaml" data-language="xaml"><code class="language-xaml">&lt;TextBlock  Height&#x3D;&quot;49&quot; HorizontalAlignment&#x3D;&quot;Left&quot; 
           Margin&#x3D;&quot;30,27,0,0&quot; Name&#x3D;&quot;TextBlock1&quot; VerticalAlignment&#x3D;&quot;Top&quot; Width&#x3D;&quot;60&quot; TextWrapping&#x3D;&quot;Wrap&quot;&gt; 
    AAAAAAABBBBBB
&lt;&#x2F;TextBlock&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>3)使用InLines属性的LineBreak来换行</p>
<p>简单的来说就是,显示的XAML表示用</p>
<pre class="line-numbers language-xaml" data-language="xaml"><code class="language-xaml">&lt;TextBlock  Height&#x3D;&quot;49&quot; HorizontalAlignment&#x3D;&quot;Left&quot; 
           Margin&#x3D;&quot;30,27,0,0&quot; Name&#x3D;&quot;TextBlock1&quot; VerticalAlignment&#x3D;&quot;Top&quot; Width&#x3D;&quot;60&quot; TextWrapping&#x3D;&quot;Wrap&quot;&gt; 
    &lt;Run&gt;AAAAAA&lt;&#x2F;Run&gt;
    &lt;LineBreak&#x2F;&gt;
    &lt;Run&gt;BBBBBB&lt;&#x2F;Run&gt;
&lt;&#x2F;TextBlock&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>后台代码添加</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">TextBlock1.Inlines.Add(New Run(&quot;AAAAAA&quot;))
TextBlock1.Inlines.Add(New LineBreak())
TextBlock1.Inlines.Add(New Run(&quot;BBBB&quot;))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>另外如果RUN里面有大量的文字表示,超过了TextBlock的Width时候,文字会被剪切掉,而不是自动换行,这点需要注意一下</p>
<h1 id="WPF美化"><a href="#WPF美化" class="headerlink" title="WPF美化"></a>WPF美化</h1><h2 id="MaterialDesignInXaml"><a href="#MaterialDesignInXaml" class="headerlink" title="MaterialDesignInXaml"></a>MaterialDesignInXaml</h2><p>美化包:MaterialDesignInXaml</p>
<p>导入包:管理Nuget程序包中搜索美化包名</p>
<p>使用前添加引用:</p>
<pre class="line-numbers language-xaml" data-language="xaml"><code class="language-xaml">xmlns:materialDesign&#x3D;&quot;http:&#x2F;&#x2F;materialdesigninxaml.net&#x2F;winfx&#x2F;xaml&#x2F;themes&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>App.xaml文件添加引用:</p>
<pre class="line-numbers language-xaml" data-language="xaml"><code class="language-xaml">&lt;ResourceDictionary&gt;
            &lt;ResourceDictionary.MergedDictionaries&gt;
                &lt;ResourceDictionary Source&#x3D;&quot;pack:&#x2F;&#x2F;application:,,,&#x2F;MaterialDesignThemes.Wpf;component&#x2F;Themes&#x2F;MaterialDesignTheme.Light.xaml&quot; &#x2F;&gt;
                &lt;ResourceDictionary Source&#x3D;&quot;pack:&#x2F;&#x2F;application:,,,&#x2F;MaterialDesignColors;component&#x2F;Themes&#x2F;Recommended&#x2F;Primary&#x2F;MaterialDesignColor.DeepPurple.xaml&quot; &#x2F;&gt;
                &lt;ResourceDictionary Source&#x3D;&quot;pack:&#x2F;&#x2F;application:,,,&#x2F;MaterialDesignColors;component&#x2F;Themes&#x2F;Recommended&#x2F;Accent&#x2F;MaterialDesignColor.Lime.xaml&quot; &#x2F;&gt;
                &lt;ResourceDictionary Source&#x3D;&quot;pack:&#x2F;&#x2F;application:,,,&#x2F;MaterialDesignThemes.Wpf;component&#x2F;Themes&#x2F;MaterialDesignTheme.Defaults.xaml&quot; &#x2F;&gt;
            &lt;&#x2F;ResourceDictionary.MergedDictionaries&gt;
            &lt;&#x2F;ResourceDictionary&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-xaml" data-language="xaml"><code class="language-xaml">&lt;Grid Name&#x3D;&quot;myGrid&quot; Width&#x3D;&quot;auto&quot; ShowGridLines&#x3D;&quot;False&quot; Background&#x3D;&quot;AliceBlue&quot;&gt;
       &lt;Grid.RowDefinitions&gt;
           &lt;RowDefinition Height&#x3D;&quot;150&quot;&#x2F;&gt;
           &lt;RowDefinition Height&#x3D;&quot;75&quot;&#x2F;&gt;
           &lt;RowDefinition Height&#x3D;&quot;75&quot;&#x2F;&gt;
           &lt;RowDefinition Height&#x3D;&quot;80&quot;&#x2F;&gt;
           &lt;RowDefinition Height&#x3D;&quot;150&quot;&#x2F;&gt;
       &lt;&#x2F;Grid.RowDefinitions&gt;
       &lt;Grid.ColumnDefinitions&gt;
           &lt;ColumnDefinition Width&#x3D;&quot;200&quot;&#x2F;&gt;
           &lt;ColumnDefinition Width&#x3D;&quot;*&quot;&#x2F;&gt;
           &lt;ColumnDefinition Width&#x3D;&quot;200&quot; &#x2F;&gt;
       &lt;&#x2F;Grid.ColumnDefinitions&gt;
       &lt;!--为什么放大窗口后textbox比textblock要长??--&gt;
       &lt;TextBlock Grid.Row&#x3D;&quot;0&quot; Grid.Column&#x3D;&quot;1&quot; Text&#x3D;&quot;登录SwissArmyKnife系统&quot; FontSize&#x3D;&quot;32&quot; TextAlignment&#x3D;&quot;Center&quot; Margin&#x3D;&quot;0,70,0,30&quot;&#x2F;&gt;
       &lt;TextBox Grid.Row&#x3D;&quot;1&quot; Grid.Column&#x3D;&quot;1&quot; Text&#x3D;&quot;请输入账号&quot;  FontSize&#x3D;&quot;32&quot; Margin&#x3D;&quot;50,15&quot;&#x2F;&gt;
       &lt;PasswordBox Grid.Row&#x3D;&quot;2&quot; Grid.Column&#x3D;&quot;1&quot;  ToolTip&#x3D;&quot;请输入密码&quot; Margin&#x3D;&quot;50,15&quot; FontSize&#x3D;&quot;32&quot;  
                    x:Name&#x3D;&quot;FloatingPasswordBox&quot;
                  
                    materialDesign:HintAssist.Hint&#x3D;&quot;请输入密码&quot;
                    materialDesign:HintAssist.Foreground&#x3D;&quot;Green&quot;
                    materialDesign:TextFieldAssist.UnderlineBrush&#x3D;&quot;Green&quot;
                    Style&#x3D;&quot;&#123;StaticResource MaterialDesignFloatingHintPasswordBox&#125;&quot; &#x2F;&gt;
       &lt;Button Grid.Row&#x3D;&quot;3&quot; Grid.Column&#x3D;&quot;1&quot; Content&#x3D;&quot;登录&quot; FontSize&#x3D;&quot;20&quot; Margin&#x3D;&quot;40,15&quot; &#x2F;&gt;
   &lt;&#x2F;Grid&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="简单对话框"><a href="#简单对话框" class="headerlink" title="简单对话框"></a>简单对话框</h3><p>来自:<a href="https://blog.csdn.net/bondw/article/details/102762482">https://blog.csdn.net/bondw/article/details/102762482</a></p>
<p>效果图:</p>
<p><img src="https://img-blog.csdnimg.cn/20191027002851125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JvbmR3,size_16,color_FFFFFF,t_70" alt="简单对话框demo"></p>
<p>定义对话框模板SampleMessageDialog.xaml</p>
<p>注意需要向解决方案添加用户控制窗口,否则会报错</p>
<pre class="line-numbers language-xaml" data-language="xaml"><code class="language-xaml">&lt;UserControl x:Class&#x3D;&quot;test.SampleMessageDialog&quot; 
    xmlns&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;winfx&#x2F;2006&#x2F;xaml&#x2F;presentation&quot; 
    xmlns:x&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;winfx&#x2F;2006&#x2F;xaml&quot; 
    xmlns:mc&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;markup-compatibility&#x2F;2006&quot; 
    xmlns:d&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;expression&#x2F;blend&#x2F;2008&quot; 
    xmlns:materialDesign&#x3D;&quot;http:&#x2F;&#x2F;materialdesigninxaml.net&#x2F;winfx&#x2F;xaml&#x2F;themes&quot; 
    mc:Ignorable&#x3D;&quot;d&quot; d:DesignHeight&#x3D;&quot;300&quot; d:DesignWidth&#x3D;&quot;300&quot; MaxWidth&#x3D;&quot;400&quot;&gt;
    &lt;Grid Margin&#x3D;&quot;16&quot;&gt;
        &lt;Grid.RowDefinitions&gt;
            &lt;RowDefinition &#x2F;&gt;
            &lt;RowDefinition &#x2F;&gt;
        &lt;&#x2F;Grid.RowDefinitions&gt;
        &lt;TextBlock x:Name&#x3D;&quot;Message&quot; Margin&#x3D;&quot;0 6 0 0&quot; FontSize&#x3D;&quot;18&quot; Grid.Row&#x3D;&quot;0&quot; &#x2F;&gt;
        &lt;Button Grid.Row&#x3D;&quot;1&quot; IsDefault&#x3D;&quot;True&quot; Style&#x3D;&quot;&#123;DynamicResource MaterialDesignFlatButton&#125;&quot; HorizontalAlignment&#x3D;&quot;Right&quot; Margin&#x3D;&quot;16 16 16 0&quot; Command&#x3D;&quot;&#123;x:Static materialDesign:DialogHost.CloseDialogCommand&#125;&quot;&gt;
            ACCEPT
        &lt;&#x2F;Button&gt;
    &lt;&#x2F;Grid&gt;
&lt;&#x2F;UserControl&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对应的SampleMessageDialog.cs</p>
<pre class="line-numbers language-none"><code class="language-none">using System.Windows.Controls;

namespace test
&#123;
    &#x2F;&#x2F;&#x2F; &lt;summary&gt;
    &#x2F;&#x2F;&#x2F; Interaction logic for SampleMessageDialog.xaml
    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;
    public partial class SampleMessageDialog : UserControl
    &#123;
        public SampleMessageDialog()
        &#123;
            InitializeComponent();
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对应的函数</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public async void MessageTips(string message, object sender, RoutedEventArgs e)
&#123;
	var sampleMessageDialog &#x3D; new SampleMessageDialog
	&#123;
		Message &#x3D; &#123; Text &#x3D; message &#125;
	&#125;;
	await DialogHost.Show(sampleMessageDialog, &quot;RootDialog&quot;);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在需要的位置使用</p>
<pre class="line-numbers language-xaml" data-language="xaml"><code class="language-xaml">MessageTips(&quot;请确认&quot;, sender, e);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>坑</strong></p>
<p>直接用,会报错:<br>System.InvalidOperationException:“No loaded DialogHost instances.”<br>原因是对话框放置的位置找不到,这个放置的位置就是这里的 <strong>RootDialog</strong></p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">await DialogHost.Show(sampleMessageDialog, &quot;RootDialog&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>需要在windows.xaml里设置,把GRID内容放入到如下容器里面</p>
<pre class="line-numbers language-xaml" data-language="xaml"><code class="language-xaml">&lt;materialDesign:DialogHost Identifier&#x3D;&quot;RootDialog&quot;&gt;
......
&lt;&#x2F;materialDesign:DialogHost&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="导入ttf"><a href="#导入ttf" class="headerlink" title="导入ttf"></a>导入ttf</h2><p>因为实现ImageButton接触ttf在wpf中的使用,ttf是图标按钮的集合文件。可在阿里<a href="http://www.iconfont.cn网站选择下载.首先选择所需图标添加到购物车,选择完成后从购物车中选择“下载代码”,便可将其中的图标打包生成ttf文件并下载至本地.下载的文件夹中包含图一所示文件,其中iconfont.ttf是程序所需文件,打开该文件可看到“字体名称”,程序根据该名称查找ttf文件.程序中引用该文件首先需将该字体包设置为resource,如fontfamily./">www.iconfont.cn网站选择下载。首先选择所需图标添加到购物车,选择完成后从购物车中选择“下载代码”,便可将其中的图标打包生成ttf文件并下载至本地。下载的文件夹中包含图一所示文件,其中iconfont.ttf是程序所需文件,打开该文件可看到“字体名称”,程序根据该名称查找ttf文件。程序中引用该文件首先需将该字体包设置为Resource,如FontFamily。</a></p>
<p>c#代码中的引用格式为“#”+”字体名称”。iconfont.cn中下载的字体名称一般都是“iconfont”,所以引用时使用“#iconfont”即可,实例截取:component&#x2F;Resources&#x2F;#iconfont”。</p>
<p><img src="https://images2015.cnblogs.com/blog/649940/201705/649940-20170519154738478-128340687.png" alt="img"></p>
<p>图中的demo_unicode.html包含了ttf文件中的unicode编码,如图二所示。wpf中引用时,在xaml和xaml.cs中的方式有所不同。如arrow-left图标的编码是“&amp;#xe614;”,当在xaml中引用时需要直接复制该编码,而在代码(.cs文件)中引用时,格式为“\ue614”。</p>
<p>  具体介绍在App.xaml中设置为程序资源(Application.Resources)的方法及使用步骤:</p>
<pre><code>步骤1,在App.xaml中设置如下,其中ttf资源文件所在目录为WpfUI/Resources/,WpfUI是项目名称,iconfont.ttf是字体库文件名,iconfont是字体库的“字体名称”。
</code></pre>
<pre class="line-numbers language-xaml" data-language="xaml"><code class="language-xaml">&lt;Application.Resources&gt;
        &lt;FontFamily x:Key&#x3D;&quot;IconFont&quot;&gt;
            pack:&#x2F;&#x2F;application:,,,&#x2F;WpfUI;component&#x2F;Resources&#x2F;iconfont.ttf#iconfont
        &lt;&#x2F;FontFamily&gt;
        &lt;!--其他设置--&gt;
&lt;&#x2F;Application.Resources&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>步骤2,在xaml中应用到目标,以设置MenuItem图标为例</p>
<pre class="line-numbers language-xaml" data-language="xaml"><code class="language-xaml">&lt;MenuItem Name&#x3D;&quot;menuItem1&quot; Header&#x3D;&quot;Icon示例&quot; Icon&#x3D;&quot;&quot; FontFamily&#x3D;&quot;&#123;StaticResource IconFont&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>当前项目常用图标地址:<a href="http://www.iconfont.cn/collections/detail?cid=4215">http://www.iconfont.cn/collections/detail?cid=4215</a></p>
<h2 id="PanuonUI-Silver"><a href="#PanuonUI-Silver" class="headerlink" title="PanuonUI.Silver"></a><strong><a href="https://gitee.com/panuon/PanuonUI.Silver">PanuonUI.Silver</a></strong></h2><p>WPF 的第三方UI库,基于PanuonUI拓展开发的</p>
<p>gitee:<a href="https://gitee.com/panuon/PanuonUI.Silver">https://gitee.com/panuon/PanuonUI.Silver</a></p>
<p>PanuonUI.Silver 2.0手册:<a href="https://www.yuque.com/mochengvia/silver2.0">https://www.yuque.com/mochengvia/silver2.0</a></p>
<h2 id="DMSkin"><a href="#DMSkin" class="headerlink" title="DMSkin"></a>DMSkin</h2><p>WPF的第三方库,看了下作者的基于自己的DMSkin写的示例程序,特别棒!</p>
<p>已经fork到自己的仓库了: <a href="https://github.com/AuntYang/DMSkin">https://github.com/AuntYang/DMSkin</a></p>
<h2 id="HandyControl"><a href="#HandyControl" class="headerlink" title="HandyControl"></a><a href="https://github.com/HandyOrg/HandyControl">HandyControl</a></h2><p>WPF的第三方库,在GitHub上开源的中国开发者开发的第三方库,目前不是特别完善,但每个月都在更新。</p>
<p>HandyControl:<a href="https://github.com/HandyOrg/HandyControl">https://github.com/HandyOrg/HandyControl</a></p>
<p>文档:<a href="https://handyorg.github.io/handycontrol">https://handyorg.github.io/handycontrol</a></p>
<h2 id="MahApps-Metro"><a href="#MahApps-Metro" class="headerlink" title=" MahApps.Metro"></a><strong><a href="https://github.com/MahApps/MahApps.Metro"> MahApps.Metro</a></strong></h2><p>WPF的第三方库,同样在Github上开源的免费库,可以在Nuget上添加引用。</p>
<p>MahApps.Metro:<a href="https://github.com/MahApps/MahApps.Metro">https://github.com/MahApps/MahApps.Metro</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>WPF</tag>
        <tag>.NET</tag>
        <tag>MaterialDesign</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Frp和Squid的代理服务器搭建</title>
    <url>/2022/0427Proxy%20server%20construction.html</url>
    <content><![CDATA[<h1 id="实现需求"><a href="#实现需求" class="headerlink" title="实现需求"></a>实现需求</h1><p>硬件:</p>
<ul>
<li>具备公网IP的主机(此处使用阿里云服务器)</li>
<li>连接校内网的主机(此处使用运行Ubunt系统的虚拟机)</li>
</ul>
<p>软件:</p>
<ul>
<li>frp(内网穿透工具)</li>
<li>squid(代理服务器工具,UNIX&#x2F;linux主要采用Squid实现代理服务器功能)</li>
</ul>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p><img src="https://s2.loli.net/2022/04/27/Tn6Y9EFy5crkueb.png" alt="代理拓扑图"></p>
<ul>
<li>为什么要云服务器?</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">校园网(校内网)是一个具备严格防火墙的局域网,公网上的设备并不能够直接访问校内网的各种资源,为了实现外网能够访问校园网,我们有两种思路,一在具备公网IP地址的云服务器和校内主机上都安装frp软件,实现内网穿透功能。二是在校内主机上架设VPN服务器,校外设备通过VPN连接校内网访问校内资源。本文采用第一种方式。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<ul>
<li>为什么要代理服务器?</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">代理服务器能够监听设备上的端口,一旦端口接受到访问请求,代理程序会按照预先设定的配置将端口中接收到的访问请求转发并返回请求内容,在校内主机上安装<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><a href="https://so.csdn.net/so/search?q=Squid&spm=1001.2101.3001.7020">Squid</a>软件,从而将校内主机变为代理服务器,能够转发来自校外设备的浏览器请求。</p>
<h1 id="实现内网穿透"><a href="#实现内网穿透" class="headerlink" title="实现内网穿透"></a>实现内网穿透</h1><h2 id="云服务器安装frp-server"><a href="#云服务器安装frp-server" class="headerlink" title="云服务器安装frp-server"></a>云服务器安装frp-server</h2><h3 id="获取frp软件"><a href="#获取frp软件" class="headerlink" title="获取frp软件"></a>获取frp软件</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /usr/local/src  <span class="token comment">#进入此目录</span>
<span class="token function">wget</span> https://github.com/fatedier/frp/releases/download/v0.38.0/frp_0.38.0_linux_amd64.tar.gz <span class="token comment">#下载frp</span>
<span class="token function">tar</span> <span class="token parameter variable">-xvf</span> frp_0.38.0_linux_amd64.tar.gz <span class="token comment">#解压;frp文件</span>
<span class="token builtin class-name">cd</span> frp_0.38.0_linux_amd64/ <span class="token comment">#进入解压后的frp文件夹</span>
<span class="token function">ls</span> <span class="token comment">#浏览文件夹</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://s2.loli.net/2022/04/27/AB7lXHTYsqaDzWd.png" alt="ls命令结果"></p>
<p>可见frp文件夹中包含了frpc和frps两个可执行文件,frpc即frp-client(客户端),frps即frp-server(服务端)</p>
<h3 id="配置frp服务器端配置文件frps-ini"><a href="#配置frp服务器端配置文件frps-ini" class="headerlink" title="配置frp服务器端配置文件frps.ini"></a>配置frp服务器端配置文件frps.ini</h3><p>用vim命令打开frps.ini文件</p>
<pre class="line-numbers language-none"><code class="language-none">[common]
bind_port &#x3D; 7000   #frp使用的端口

dashboard_user &#x3D; admin    #流量监控的账户  自己设置
dashboard_pwd &#x3D; 123456    #流量监控的密码   自己设置
dashboard_port &#x3D; 6440     #流量监控程序的端口,搭建完成之后用 云服务器IP:6440 就可以打开流量监控网页程序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="启动frp服务端"><a href="#启动frp服务端" class="headerlink" title="启动frp服务端"></a>启动frp服务端</h3><pre class="line-numbers language-none"><code class="language-none">nohup .&#x2F;frps -c .&#x2F;frps.ini &amp;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>注:nohup的作用是让我在关闭Xshell远程连接时,frp服务端不会跟ssh进程一起关闭。<br>参考文档:<br><a href="https://blog.csdn.net/gatieme/article/details/52777721">解决Linux关闭终端(关闭SSH等)后运行的程序自动停止</a><br><a href="https://blog.csdn.net/davidhzq/article/details/102766881">在linux后台运行脚本命令和程序的方法大全</a></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><img src="https://s2.loli.net/2022/04/27/uKyGrtOgTzNWQin.png" alt="在这里插入图片描述">注意事项</h3><p>国内云服务器大多都要配置安全组的,以阿里云为例,配置规则里更改访问规则,从而打开需要用到的端口。</p>
<h2 id="在校内主机安装frp-client"><a href="#在校内主机安装frp-client" class="headerlink" title="在校内主机安装frp-client"></a>在校内主机安装frp-client</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /usr/local/src  <span class="token comment">#进入此目录</span>
<span class="token function">wget</span> https://github.com/fatedier/frp/releases/download/v0.38.0/frp_0.38.0_linux_amd64.tar.gz      <span class="token comment">#笔者这里用的版本和云服务器的一样,读者在Github选择自己合适的版本</span>
<span class="token function">tar</span> <span class="token parameter variable">-xvf</span> frp_0.38.0_linux_amd64.tar.gz <span class="token comment">#解压文件</span>
<span class="token builtin class-name">cd</span> frp_0.31.1_linux_amd64/
<span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://s2.loli.net/2022/04/27/R4n5vMAlhk8BUzL.png" alt="ls命令结果"></p>
<h3 id="配置frp客户端配置文件frpc-ini"><a href="#配置frp客户端配置文件frpc-ini" class="headerlink" title="配置frp客户端配置文件frpc.ini"></a>配置frp客户端配置文件frpc.ini</h3><p>用vim命令打开frpc.ini文件。</p>
<pre class="line-numbers language-ini" data-language="ini"><code class="language-ini"><span class="token section"><span class="token punctuation">[</span><span class="token section-name selector">common</span><span class="token punctuation">]</span></span>
<span class="token key attr-name">server_addr</span> <span class="token punctuation">=</span> <span class="token value attr-value">&lt;你的云服务器IP地址></span>
<span class="token key attr-name">server_port</span> <span class="token punctuation">=</span> <span class="token value attr-value">7000</span>

<span class="token section"><span class="token punctuation">[</span><span class="token section-name selector">ssh</span><span class="token punctuation">]</span></span>
<span class="token key attr-name">type</span> <span class="token punctuation">=</span> <span class="token value attr-value">tcp</span>
<span class="token key attr-name">local_ip</span> <span class="token punctuation">=</span> <span class="token value attr-value">127.0.0.1</span>
<span class="token key attr-name">local_port</span> <span class="token punctuation">=</span> <span class="token value attr-value">22        #local_port端口是校内主机的ssh端口号</span>
<span class="token key attr-name">remote_port</span> <span class="token punctuation">=</span> <span class="token value attr-value">6001     #remote_port端口是云服务器的端口号。此端口自己设置,实现当你用Xshell连接 云服务器IP地址:6001即是在连接你校内主机的SSH端口</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>启动frp客户端</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./frpc <span class="token parameter variable">-c</span> ./frpc.ini <span class="token comment">#若需要关闭终端后仍继续运行,参考上文云服务器端命令</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="测试frp是否搭建成功"><a href="#测试frp是否搭建成功" class="headerlink" title="测试frp是否搭建成功"></a>测试frp是否搭建成功</h2><p>用Xshell连接,连接地址填 云服务器IP地址:6001,用户名和密码填校内主机的。如果ssh能够成功连接,则成功实现内网穿透。<br>frp官方提供的教程:<a href="https://gofrp.org/docs/examples/ssh/">通过SSH访问内网机器</a></p>
<h1 id="校内主机实现代理服务器功能"><a href="#校内主机实现代理服务器功能" class="headerlink" title="校内主机实现代理服务器功能"></a>校内主机实现代理服务器功能</h1><h2 id="校内主机安装Squid软件"><a href="#校内主机安装Squid软件" class="headerlink" title="校内主机安装Squid软件"></a>校内主机安装Squid软件</h2><p>安装软件</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum <span class="token function">install</span> squid <span class="token parameter variable">-y</span>
yum <span class="token function">install</span> httpd-tools <span class="token parameter variable">-y</span>  
<span class="token comment">#以上两命令适用于centos</span>
<span class="token function">apt</span> <span class="token function">install</span> squid <span class="token parameter variable">-y</span>
<span class="token function">apt</span> <span class="token function">install</span> apache2-utils <span class="token parameter variable">-y</span>
<span class="token comment">#以上两条命令适用于Ubuntu</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>生成密码文件</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> /etc/squid3/
<span class="token comment">#ikaros 是用户名</span>
htpasswd <span class="token parameter variable">-cd</span> /etc/squid3/passwords ikaros
<span class="token comment">#提示输入密码,比如输入123456</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://s2.loli.net/2022/04/27/Cb5KoEj6Nk2Flim.png" alt="生成密码文件执行结果"></p>
<p>测试密码文件</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/usr/lib64/squid/basic_ncsa_auth /etc/squid3/passwords
<span class="token comment">#输入用户名 密码</span>
ikaros  <span class="token number">123456</span>
<span class="token comment">#提示ok说明成功</span>
ok
<span class="token comment">#ctrl+c退出</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://s2.loli.net/2022/04/27/lyeFmL3x5dg9W6U.png" alt="测试密码文件执行结果"></p>
<p>配置squid.conf文件</p>
<pre class="line-numbers language-ini" data-language="ini"><code class="language-ini">vim /etc/squid/squid.conf
<span class="token comment">#在最后添加</span>
auth_param basic program /usr/lib64/squid/basic_ncsa_auth /etc/squid3/passwords
auth_param basic realm proxy
acl authenticated proxy_auth REQUIRED
http_access allow authenticated

<span class="token comment"># And finally deny all other access to this proxy</span>
http_access allow all

<span class="token comment"># Deny CONNECT to other than secure SSL ports</span>
http_access allow CONNECT !SSL_ports

<span class="token comment">#这里是端口号,可以按需修改</span>
<span class="token comment">#http_port 3128 这样写会同时监听ipv6和ipv4的端口,推荐适应下面的配置方法。</span>
http_port 0.0.0.0:3128
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>squid软件相关命令</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#启动start</span>
systemctl start squid.service
<span class="token comment">#停止stop</span>
systemctl stop squid.service
<span class="token comment">#重启stop</span>
systemctl restart squid.service
<span class="token comment">#配置开机自启动</span>
systemctl <span class="token builtin class-name">enable</span> squid.service
<span class="token comment">#关闭开机自启动</span>
systemctl disable squid.service
<span class="token comment">#查看运行状态</span>
systemctl status squid.service
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://s2.loli.net/2022/04/27/dXsaZYW2DNJzjw4.png" alt="执行启动命令结果"></p>
<p>参考教程:<a href="https://zhuanlan.zhihu.com/p/123048354">Centos7搭建Squid代理服务器</a></p>
<h2 id="修改校内主机frp客户端配置文件frpc-ini"><a href="#修改校内主机frp客户端配置文件frpc-ini" class="headerlink" title="修改校内主机frp客户端配置文件frpc.ini"></a>修改校内主机frp客户端配置文件frpc.ini</h2><p>我们在4.1步骤里添加了校内主机3128端口为代理服务器的端口,所有到此端口的浏览器请求都会被此端口转发出去。<br>此时我们还得更改校内主机frp客户端配置文件frpc.ini,从而使云服务器所收到的浏览器请求转发到校内主机的3128端口。</p>
<p>Xshell以root身份连接校内主机</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /usr/local/src/frp_0.38.0_linux_amd64/    <span class="token comment">#进入校内服务器的存放frp文件的目录</span>
<span class="token function">vim</span> frpc.ini

<span class="token comment">#在最后添加</span>
<span class="token comment">#[proxy-http]</span>
<span class="token comment">#local_ip = 127.0.0.1</span>
<span class="token comment">#local_port = 3128</span>
<span class="token comment">#remote_port = 8000    此端口自己设置,步骤五会用到。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>重启frp客户端</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">nohup</span> ./frpc <span class="token parameter variable">-c</span> ./frpc.ini <span class="token operator">&amp;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果报以下错误,说明之前的frp客户端还没关闭。关闭方法可kill此进程,具体方法百度如何重启frp客户端。</p>
<p><img src="https://s2.loli.net/2022/04/27/oQBaIVYXvGqSfg1.png" alt="错误"></p>
<h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>到了这一步,校园网代理就算搭建完毕,可以直接使用windows连接我们的代理。看校外的笔记本电脑是否呢能够免费下载知网,以及顶会期刊论文。</p>
<p>打开windows菜单-&gt;设置-&gt;网络与Internet-&gt;代理</p>
<p><img src="https://s2.loli.net/2022/04/27/dgYZ3nb6hq4jlxR.png" alt="win10设置代理"></p>
<p>在地址一栏填上你的云服务器IP地址,端口填8000(在4.2这一步设置的),然后打开使用代理服务器的开关</p>
<p>然后打开浏览器,就可以成功访问校园网资源</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
        <tag>代理服务器</tag>
        <tag>frp</tag>
        <tag>squid</tag>
      </tags>
  </entry>
  <entry>
    <title>CCTV-探索发现观看记</title>
    <url>/2023/03299392.html</url>
    <content><![CDATA[<p>很久没看中央十套的《探索发现》了,非常经典的系列节目,现在还一直记得小时候在“大屁股电视”上看得津津有味,现在IPTV普及了,再从CCTV4K频道上看观感还是蛮不错得。只是《探索发现》还是原来的老味道,或许制片班子还没退休吧?仍然是上集扑朔迷离,下集就豁然开朗了,经典老配方。</p>
<div class="douban-card-block">
    <a class="douban-card" href="https://movie.douban.com/subject/36221204">
        <div bg-lazy class="douban-card-bgimg" style="background-image: url('https://images.weserv.nl/?url=https://img2.doubanio.com/view/photo/s_ratio_poster/public/p2887096663.jpg');"></div>
        <div class="douban-card-left">
            <div bg-lazy class="douban-card-img" style="background-image: url('https://images.weserv.nl/?url=https://img2.doubanio.com/view/photo/s_ratio_poster/public/p2887096663.jpg');"></div>
            <div class="douban-card-status">我看过这部电视剧2023-03-29</div>
        </div>
        <div class="douban-card-right">
            <div class="douban-card-item"><span>电影名: </span><strong>茶园山南宋古墓之谜(2023)</strong></div>
            <div class="douban-card-item"><span>导演: </span><span>{{director}}</span></div>
            <div class="douban-card-item"><span>主演: </span><span>{{actors}}</span></div>
            <div class="douban-card-item"><span>上映时间: </span><span>2023-01-14(中国大陆)</span></div>
            <div class="douban-card-item"><span>评分: </span><span></span></div>
        </div>
    </a>
</div>

<p>今天看得是《茶园山南宋古墓之谜》,我看标题就知道是那个味儿。所以看这个系列的片子确实憋不出什么观感来,但有些知识、古文和观点还是值得一提、值得一记的。</p>
<h3 id="三合土"><a href="#三合土" class="headerlink" title="三合土"></a>三合土</h3><p><img src="https://s2.loli.net/2023/03/29/7Z52sVWhKbzSaJF.png" alt="三合土封棺"></p>
<p>我在看的时候就比较好奇,古代也有三合土?跟现代的三合土一样吗?建筑学概念:</p>
<blockquote>
<p>三合土是一种建筑材料。它由石灰、碎砖和细砂所组成 ,其实际配比视泥土的含沙量而定。经分层夯实,具有一定强度和耐水性,多用于建筑物的基础或路面垫层。</p>
<p align="right">——百度百科</p>
</blockquote>
<p>看了下wikipedia,词条似乎无人编辑。实际上三合土是一种中国本土的叫法,我国历史上不同时代三合土的三种材料使用都不一样,但都叫三合土,在古代这种叫法常用于墓葬领域,三合土封棺法。</p>
<h3 id="棺与椁"><a href="#棺与椁" class="headerlink" title="棺与椁"></a>棺与椁</h3><p><img src="https://s2.loli.net/2023/03/29/wq4RdvNHjlVt7zG.png" alt="棺与椁"></p>
<p>平时都是见到的词是棺椁,而棺与椁其实是两样东西,它们组成了装殓尸体的器具,也就是泛指的“棺材”。</p>
<p>棺:装殓尸体的器具,灵柩(jiù)同为此意。</p>
<p>椁:套在棺外的外棺,就是棺材外面套的大棺材</p>
<h3 id="印金山茶梅花边对襟合领绉纱单衣"><a href="#印金山茶梅花边对襟合领绉纱单衣" class="headerlink" title="印金山茶梅花边对襟合领绉纱单衣"></a>印金山茶梅花边对襟合领绉纱单衣</h3><p><img src="https://s2.loli.net/2023/03/29/jUfTpL9CxVdYQHr.jpg" alt="印金山茶梅花边对襟合领绉纱单衣"></p>
<p>这件单衣的名字着实体现了古代贵族衣着服饰的精美之所在,咋一看只是一件普通的衣物,但不知道名字真的不知道这件单衣的制作工艺如此繁复,在距今700多年的南宋织造出这样一件单衣,真是令人惊叹。</p>
<p><strong>印金山茶梅花边</strong>指的是图中衣襟部分的装饰。</p>
<p>宋代褙子的领型有直领对襟式、斜领交襟式、盘领交襟式三种</p>
<p><strong>合领</strong>其实不是指某种形制,它是一种叫法。直领对襟的领子两襟可以完全靠上的,就可以称之为合领。</p>
<p><strong>烟色</strong>指的是单衣的染色。</p>
<p><strong>绉纱</strong>指的是单衣的材质。</p>
<p>这里是一些宋制汉服的知识。</p>
<h3 id="银镏金转官毬纹帔坠"><a href="#银镏金转官毬纹帔坠" class="headerlink" title="银镏金转官毬纹帔坠"></a>银镏金转官毬纹帔坠</h3><p><img src="https://s2.loli.net/2023/03/29/HzlhdA1jVRPq4xY.png" alt="银镏金转官毬纹帔坠"></p>
<p>如果古装剧看的比较多,就能看到古装着衣时常见的装饰——帔坠。</p>
<p>这个帔坠的名字是这样断句的:银镏金&#x2F;转官&#x2F;毬(qiú)纹&#x2F;帔坠。</p>
<p>银镏金是帔坠材质,转官是帔坠上的字样,毬纹是帔坠的花纹样式。</p>
<p><strong>转官</strong>:宋代升迁官职的说法。</p>
<p><strong>帔(pèi)坠</strong>:使衣服下垂的装饰品。</p>
<h3 id="剔犀葵瓣式漆奁"><a href="#剔犀葵瓣式漆奁" class="headerlink" title="剔犀葵瓣式漆奁"></a>剔犀葵瓣式漆奁</h3><p><img src="https://s2.loli.net/2023/03/29/JmD1wHNEnKfQoZk.png" alt="剔犀葵瓣式漆奁"></p>
<p>奁(lián)是古代妇女梳妆用的镜匣。而漆奁则是指其制作工艺为漆制。</p>
<h3 id="渚"><a href="#渚" class="headerlink" title="渚"></a>渚</h3><p><img src="https://s2.loli.net/2023/03/29/kV9if8wjFuRlIOP.png" alt="鄂渚"></p>
<p>渚:水中小块陆地。</p>
<p>杜甫《登高》中“渚清沙白鸟飞回”的<strong>渚</strong>即为此意。</p>
<h3 id="暂厝"><a href="#暂厝" class="headerlink" title="暂厝"></a>暂厝</h3><p><img src="https://s2.loli.net/2023/03/29/jgouUZp89FqyRiJ.png" alt="暂厝"></p>
<p>暂厝(cuò):人死后浅埋以待改葬或停柩(jiù)待葬。</p>
<h3 id="语病错误"><a href="#语病错误" class="headerlink" title="语病错误"></a>语病错误</h3><p><img src="https://s2.loli.net/2023/03/29/3dqoLcu1EyKSpQG.jpg" alt="语病错误"></p>
<p>旁白:</p>
<p align="center"><i>“为何当时起重机吊不起棺椁的原因”</i></p>

<p>我没想到的是中央台也会有这种错误。</p>
<p>最后,纪录片中一位馆长的一句话我非常认同。</p>
<p><img src="https://s2.loli.net/2023/03/29/JUScgnkM7Hy1hVZ.jpg" alt="金句"></p>
]]></content>
      <categories>
        <category>纪录片</category>
      </categories>
      <tags>
        <tag>探索发现</tag>
        <tag>观剧</tag>
        <tag>纪录片</tag>
        <tag>考古</tag>
      </tags>
  </entry>
  <entry>
    <title>无线传感器网络必背习题</title>
    <url>/2020/1209wsn%20study.html</url>
    <content><![CDATA[<p>填空题:</p>
<ol>
<li>传感器网络三大基本要素:<em>传感器</em>、<em>感知对象</em>、<em>观测者</em></li>
<li>传感器节点的基本功能模块包括: <em>数据采集模块</em> 、 <em>数据处理和控制模块</em> 、<br><em>通信模块</em> 、<em>供电模块</em>四个,其中 <em>通信模块</em> 能量消耗最大。</li>
<li>传感器节点通信模块的工作模式有 <em>发送</em> 、 <em>接收</em> 、 <em>空闲</em> 和 <em>睡眠</em> 。</li>
<li>无线传感器网络拓扑控制主要通过 <em>功率调节</em> 和 <em>睡眠调度机制</em> 两种方式实现。</li>
<li>传感器网络中的平面路由协议主要有 <em>洪泛路由</em> 、 <em>闲聊法</em> 、<em>SPIN</em> 等。</li>
<li>传感器网络中的路由协议按照节点在路由过程中是否有层次结构、作用是否有差异,可分为<br><em>平面路由协议</em> 和 <em>层次路由协议</em> 。</li>
<li><em>K-连通</em> 指至少去掉 k 个节点才能使网络不连通。</li>
<li><em>目标定位</em> 是确定网络覆盖范围内其他目标节点的坐标位置。</li>
<li>*无线传感器网络经典 MAC 协议是 <em>S-MAC</em>,它主要特征是<br><em>提供良好的扩展性、减少节点能量消耗</em> 。</li>
<li>无线传感器网络根据覆盖目标不同,将覆盖算法分为 <em>点覆盖</em> 、 <em>面覆盖</em> 、<br><em>栅栏覆盖</em> 三种类型。</li>
<li>传感器网络拓扑结构包括 <em>平面网络结构</em> 、 <em>分级网络结构</em> 、 <em>混合网络结构</em><br>、<em>Mesh 网络结构</em> 四种。</li>
<li><em>洪泛</em> 路由协议是无线传感器网络中最基本、最简单的平面路由协议。</li>
<li>传感器网络中的路由协议按照传输过程中采用的路径多少分为: <em>单路径路由协议</em></li>
</ol>
<p>和 <em>多路径路由协议</em> 。</p>
<ol>
<li>无线传感器网络中节点部署方式主要分为 <em>确定性部署</em> 、 <em>随机性部署</em> 、<br><em>混合式部署</em> 三种。</li>
<li>实现传感器节点时间同步的同步消息包括 <em>单向消息交换</em> 、 <em>双向消息交换</em> 、<br><em>接收端-接收端同步</em> 三种。</li>
<li>无线传感器网络时间同步协议 TPSN 实现包括 <em>级别探索</em> 和 <em>同步</em> 两个阶段。</li>
<li>节点覆盖感知模型主要有 <em>布尔感知模型</em> 和 <em>概率感知模型</em> 。</li>
<li>混合网络拓扑结构中包括基本的 <em>平面</em> 和 <em>分级</em> 两种网络结构。</li>
<li>典型的覆盖算法包括 <em>最佳与最坏情况覆盖</em> 、 <em>圆周覆盖</em> 、和连通传感器覆盖等。</li>
<li>按源节点获取路径的方法: <em>主动路由协议</em> 、 <em>按需路由协议</em> 、 <em>混合路由协议</em><br>。</li>
<li>按节点参与通信的方式: <em>直接通信路由协议</em> 、 <em>平面路由协议</em> 、<br><em>层次路由协议</em> 。</li>
<li>按路由的发现过程: <em>以位置信息为中心的路由协议</em> 、 <em>以数据为中心的路由协议</em><br>。</li>
<li>无线通信介质主要包括 <em>无线电波</em> 、 <em>红外线</em> 、 <em>微波</em> 、 <em>卫星</em> 。</li>
<li>列举三个与距离无关的定位方法 <em>质心定位算法</em> 、 <em>凸规划定位算法</em> 、<em>APS<br>定位算法</em> 。</li>
<li>无线传感器网络传输层协议主要实现 <em>event-to-sink</em> 和 <em>sink-to-sensors</em><br>两种方式消息的传送。</li>
<li>根据信息的抽象程度,数据融合分为 <em>数据级融合</em> 、 <em>特征级融合</em> 、<br><em>决策级融合</em> 。</li>
<li>传感器网络节能的主要策略有 <em>休眠机制</em> 、 <em>数据融合机制</em> 。</li>
<li>常用的短距离无线通信技术包括 <em>蓝牙</em> 、<em>Zigbee</em>、<em>UWB</em>、<em>WIFI</em> 等。</li>
<li>*无线传感器网络接入 Internet 网络的方式有 <em>以太网</em> 、 <em>无线局域网</em> 、</li>
</ol>
<p><em>移动通信网</em> 、 <em>有线电视网</em> 等。</p>
<ol>
<li>名词解释:(只要给出缩写的全名中文意思,不需要解释)</li>
</ol>
<p>WSN:无线传感器网络</p>
<p>ISO:国际标准化组织</p>
<p>MAC:介质访问控制</p>
<p>RSSI:接收信号强度指示</p>
<p>ToA:(基于)到达时间定位法</p>
<p>TDoA:(基于)到达时间差定位法</p>
<p>AOA:(基于)到达角</p>
<p>LoS:视线传输&#x2F;同步丢失</p>
<p>TDMA:时分复用&#x2F;时分多址</p>
<p>SNEP:传感器网络加密协议</p>
<p>MST:最小生成树</p>
<p>LMST:本地最小生成树</p>
<p>RNG:相关(相对)邻近图</p>
<p>DRNG:有向相关(相对)邻近图</p>
<p>ARQ:自动重传请求</p>
<p>AP:接入点</p>
<p>CSMA&#x2F;CA:带有冲突避免的载波侦听多路访问</p>
<p>PCF:点协调功能</p>
<p>DCF:分布式协调功能</p>
<p>RTS&#x2F;CTS:请求发送&#x2F;允许发送协议</p>
<p>WPAN:无线个人网络</p>
<ol>
<li>简答题:</li>
<li>简述无线传感器网络的定义及特点。</li>
</ol>
<p>定义:无线传感器网络是大量的静止或移动的传感器以自组织和多跳的方式构成的无线网络</p>
<p>特点:自组织性、以数据为中心、应用相关性、动态性、网络规模大、可靠性、集成化、协作方式执行任务</p>
<ol>
<li>简述无线传感器网络的关键技术包含哪些。</li>
</ol>
<p>关键技术:拓扑控制、路由协议、时间同步、定位技术、数据融合、异构网络的互联互通、信息安全技术、大结构关联协同处理数据</p>
<ol>
<li>简述无线传感器网络拓扑控制的定义及评价指标有哪些。</li>
</ol>
<p>定义:拓扑控制(topology<br>control)是一种协调节点间各自传输范围的技术,用以构建具有某些期望的全局特性(如,连通性)的网络拓扑结构,同时减少节点的能耗或增加网络的传输能力</p>
<p>评价指标:连通性、覆盖性、吞吐量、扩展性、鲁棒性</p>
<ol>
<li>简述无线传感器网络协议结构及各层功能。</li>
</ol>
<p>无线传感器网络协议由<strong>物理层、数据链路层、网络层、传输层和应用层</strong>组成</p>
<p><img src="https://s2.loli.net/2021/12/05/KUOqu3RQP1rfXHa.png" alt="图片"></p>
<ol>
<li>简述无线传感器网络安全需求有哪些。</li>
</ol>
<p>数据保密性、数据认证、数据完整性、数据实时性、密钥管理、真实性、扩展性、可用性、自组织性、鲁棒性等</p>
<ol>
<li>简述 S-MAC 协议工作方式以及优势与不足。</li>
</ol>
<p>S-MAC 协议是在 802.11MAC<br>协议的基础上,针对于传感器网络的节省能量的需求而提出的传感器网络的 MAC 协议;<br>通常情况下传感器网络的数据传输量少,节点协作完成共同的任务,网络内部能够进行数据的处理和融合以减少数据通信量,网络能够容忍一定程度的通信延迟;</p>
<p>工作机制:周期性侦听和睡眠、流量自适应侦听机制、串音避免、消息传递。</p>
<p>优点:</p>
<p>(1)采用流量自适应侦听机制,减少了网络中的传输延迟。</p>
<p>(2)通过睡眠机制减少了空闲侦听的能量消耗,实现简单。</p>
<p>缺点:</p>
<p>(1)竞争窗口固定导致在网络流量较大情况下,会造成网络吞吐量较低而能耗和时延较高。</p>
<p>(2)当网络负载较低的时候,由于 SMAC<br>协议采用固定的周期性侦听&#x2F;睡眠机制,节能效果并不理想.</p>
<ol>
<li>简述 WSN 接入 Internet 的实现方式。</li>
</ol>
<p>以太网、无线局域网、移动通信网、有线电视网、卫星、5G</p>
<p>应用层网关</p>
<p>延时容忍网络</p>
<p>TCP&#x2F;IP 覆盖传感器网络协议栈</p>
<p>传感器网络协议栈覆盖 TCP&#x2F;IP</p>
<p>移动代理</p>
<ol>
<li>简述 WSN 路由协议的分类及分类标准有哪些(至少 3 种)。</li>
</ol>
<p>1、按源节点获取路径的方法:主动路由协议、按需路由协议、混合路由协议。</p>
<p>2、按节点参与通信的方式:直接通信路由协议、平面路由协议、层次路由协议。</p>
<p>3、按路由的发现过程:以位置信息为中心的路由协议、以数据为中心的路由协议。</p>
<ol>
<li>应用题:</li>
<li>画出无线传感器网络系统功能结构图,简单叙述各组成部分的功能及相关关系。</li>
</ol>
<p><img src="https://s2.loli.net/2021/12/05/qJd6y2YNeo4ZzPg.png" alt="图片"></p>
<p>传感器网络包括传感器节点,汇聚节点和管理节点</p>
<p>传感器节点大量部署在在某一监测区域内,节点以自组织的形式构成无线网络,以协作的方式实时感知、采集和处理网络覆盖区域的信息,并通过多跳的方式经由汇聚节点链路将整个区域的信息传送到远程控制管理中心,且远程控制管理中心也可以对网络节点进行实时监控和操作</p>
<ol>
<li>画出传感器网络的平面网络拓扑结构图(包含基站与普通节点),说明网络节点的工作方式,及优缺点。</li>
</ol>
<p><img src="https://s2.loli.net/2021/12/05/g7UqS4dzCYh6DOM.png" alt="图片"></p>
<p>平面网络结构所有节点为对等结构,具有完全一·致的功能特性,也就是说每个节点均包含<br>相同的 MAC、路由、管理和安全等协议。是无线传感器网络中最简单的一种拓扑结构</p>
<p>优点:网络拓扑结构简单,易维护,具有较好的健壮性</p>
<p>缺点:没有中心管理节点,采用自组织协同算法形成网络,组网算法复杂</p>
<ol>
<li>画出传感器网络的层次结构拓扑结构图(包含基站与普通节点),说明网络节点的工作方式,及优缺点。</li>
</ol>
<p><img src="https://s2.loli.net/2021/12/05/UVAzH132N7JdKQg.png" alt="图片"></p>
<p>特点(工作方式):</p>
<p>(1)网络分为上层和下层两个部分,上层为中心骨干节点,下层为一般传感器节点</p>
<p>(2)通常网络可能存在一个或多个骨干节点</p>
<p>(3)所有骨干节点为对等结构</p>
<p>(4)分级网络通常以簇的形式存在</p>
<p>(5)网络拓扑结构扩展性好</p>
<p>优点:扩展性好,便于集中管理,可以降低系统建设成本,提高网络效率和可靠性</p>
<p>缺点:集中管理开销大,硬件成本高,一般节点不能直接通信</p>
<ol>
<li>简述 LEACH 协议实现过程。</li>
</ol>
<p>LEACH 是一种自适应分簇拓扑算法,它的执行是周期性的,每轮循环分为簇的建立</p>
<p>阶段和稳定的数据通信阶段。</p>
<p>簇的建立阶段:相邻节点动态地形成簇,随机产生簇头</p>
<p>数据通信阶段:簇内节点把数据发给簇头,簇头进行数据融合并把结果发给汇聚节点。</p>
<p>簇头耗能大,所以需要等概率选取簇头。使整个网络的能量负载达到均衡。</p>
<p>基本思想:网络周期地随机选择簇头,其它非簇头节点以就近原则加入相应簇头,形成虚<br>拟簇。簇内 节点将感知到的消息直接发送给簇头,由簇头转发给汇聚节点,簇头节点可<br>以将本簇内的 数据进行融合处理以减少网络传输的数据量</p>
<ol>
<li>简述基于节点度的功率控制算法实现过程(或伪代码),以本地平均算法为例说明。</li>
</ol>
<p>给定节点度的上限和下限,动态地调整节点发射功率,使节点的度数始终维持在度数的上限<br>和下限之间.LMA 算法利用局部信息来调整相邻节点的连通性,从而在保证网络连通的同时<br>使得节点间的链路具有一定的冗余性和扩展性。</p>
<p><img src="https://s2.loli.net/2021/12/05/jNemVhHafoDRuAg.png" alt="图片"></p>
<ol>
<li>简述无线传感器网络时间同步协议(TPSN)实现过程。</li>
</ol>
<p>传感器网络的时间同步协议(TPSN)是另一种传统的使用树结构组织网络的“发射端-接收端”同步方式。TPSN<br>同步有两个过程:级别探测阶段(在网络部署时执行)和同步阶段。</p>
<p>(1)级别探测阶段</p>
<p>这个阶段的目标是创建网络的分层拓扑结构,每个节点被分配了一个级别,根节点(例如一个配备了<br>GPS,可以通向外部世界的网关)驻留在级别 0。根节点通过发出一个 level_discovery<br>消息开始这个过程,这个消息包含了级别信息和发射者独有的身份信息。</p>
<p>(2)同步阶段</p>
<p>在同步阶段,TPSN 沿着在前一阶段建立起的分层结构的边缘使用双向同步机制,也就是每个<br>i 级节点会与处于 i-1 级的节点进行时钟同步。</p>
<p><img src="https://s2.loli.net/2021/12/05/YAmJe6oNHEchSQa.png" alt="图片"></p>
<ol>
<li>掌握基于 RSSI、TOA、TDOA、AOA 测距的理论基础及计算过程。</li>
</ol>
<p><img src="https://s2.loli.net/2021/12/05/QSZH6UqsXK5LyaW.png" alt="图片"></p>
<p><img src="https://s2.loli.net/2021/12/05/14UaqCsmeugy9ri.png" alt="图片"></p>
<p><img src="https://s2.loli.net/2021/12/05/81aBg62Qr5Xfs7h.png" alt="图片"></p>
<p><img src="https://s2.loli.net/2021/12/05/xe1wsWBTEr6tYuo.png" alt="图片"></p>
<p><img src="https://s2.loli.net/2021/12/05/5WXBpsVSMN2foLu.png" alt="图片"></p>
<p><img src="https://s2.loli.net/2021/12/05/RxybcQvFsS4iPoq.png" alt="图片"></p>
<p><img src="https://s2.loli.net/2021/12/05/I2qztME1JA9cTFG.png" alt="图片"></p>
<p><img src="https://s2.loli.net/2021/12/05/KTuzP9hketRsSFC.png" alt="图片"></p>
<p><img src="https://s2.loli.net/2021/12/05/vk5V1zYOSbyDRIj.png" alt="图片"></p>
<p><img src="https://s2.loli.net/2021/12/05/gFN82fq7Ie5lYDX.png" alt="图片"></p>
<p><img src="https://s2.loli.net/2021/12/05/Qq4mAEnYas7cwX5.png" alt="图片"></p>
<ol>
<li>掌握三边定位法、极大似然定位法理论基础及计算过程。</li>
</ol>
<p><img src="https://s2.loli.net/2021/12/05/ybICYZLXeAT8oWp.png" alt="图片"></p>
<p><img src="https://s2.loli.net/2021/12/05/si56kBjzxvJI3cY.png" alt="图片"></p>
<p><img src="https://s2.loli.net/2021/12/05/UcfJkrYe2P1lqTs.png" alt="图片"></p>
<p><img src="https://s2.loli.net/2021/12/05/GmKSn37B16q4RCD.png" alt="图片"></p>
<p><img src="https://s2.loli.net/2021/12/05/d5tcRe1qArjYwmz.png" alt="图片"></p>
<p><img src="https://s2.loli.net/2021/12/05/u9wp2xFs7mtKOl5.png" alt="图片"></p>
<p><img src="https://s2.loli.net/2021/12/05/u9wp2xFs7mtKOl5.png" alt="图片"></p>
<p><img src="https://s2.loli.net/2021/12/05/3N2BLOEDSd5e8l6.png" alt="图片"></p>
<ol>
<li>**掌握 DV-Hop 定位实现过程。</li>
</ol>
<p><img src="https://s2.loli.net/2021/12/05/qJa6FEdfMKlxvkA.png" alt="图片"></p>
<p><img src="https://s2.loli.net/2021/12/05/BoyVd8IYUERuALZ.png" alt="图片"></p>
<p><img src="https://s2.loli.net/2021/12/05/riLZow4WMAPdYhe.png" alt="图片"></p>
<p><img src="https://s2.loli.net/2021/12/05/Ceci2QUPqDyVAu1.png" alt="图片"></p>
<p><img src="https://s2.loli.net/2021/12/05/yDPTKBWmQo43jv5.png" alt="图片"></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>WSN</tag>
        <tag>无线传感器网络</tag>
      </tags>
  </entry>
  <entry>
    <title>智能家居控制系统开发笔记</title>
    <url>/2021/06113622.html</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="段错误"><a href="#段错误" class="headerlink" title="段错误"></a>段错误</h2><p>段错误: C&#x2F;C++<br>segmentation  fault</p>
<p>内存的非法访问。 &lt;&#x3D;  段错误<br>不能读的内存,你去读<br>不能写的内存,你去写<br>不是你的内存,你去访问</p>
<p>指针(数组)有误</p>
<pre class="line-numbers language-none"><code class="language-none">int a[10];
	int i &#x3D; 11;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">a[i] ;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">int *p &#x3D; NULL;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">a &#x3D; *p;
	*p &#x3D; 250;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">int *p1;  &#x2F;&#x2F;p1野指针
		*p1;  &#x3D;&gt; 内存的非法访问<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>一个进程运行过程中,出现段错误啦,操作系统是如何处理的呢?<br>把这个进程给kill掉。</p>
<p>找段错误,比较容易:<br>加打印。</p>
<pre class="line-numbers language-none"><code class="language-none">printf(&quot;abc\n&quot;);   &#x3D;&gt; abc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">xxxx();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">printf(&quot;123\n&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>printf(“%s L_%d\n”, __FUNCTION__, __LINE__ );</p>
<pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>__FUNCTION__  字符串,函数名<br>__LINE__     int, 当前行号<br>__FILE__    字符串,文件名</p>
<h1 id="Linux交叉开发环境搭建"><a href="#Linux交叉开发环境搭建" class="headerlink" title="Linux交叉开发环境搭建"></a>Linux交叉开发环境搭建</h1><h2 id="项目开发规范"><a href="#项目开发规范" class="headerlink" title="项目开发规范"></a>项目开发规范</h2><h3 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h3><p>缩进问题</p>
<p>对齐问题</p>
<h3 id="文件规范"><a href="#文件规范" class="headerlink" title="文件规范"></a>文件规范</h3><p>模块化思想开发</p>
<p>文件夹规范</p>
<p>smart_home&#x2F; &lt;&lt;&lt;&lt;&lt; 包含项目的所有资料<br>src&#x2F; &lt; —-包含工程源代码<br>main.c&#x2F;main.h<br>lcd.c&#x2F;lcd.h<br>ts.c&#x2F;ts.h<br>….</p>
<h2 id="代码编译"><a href="#代码编译" class="headerlink" title="代码编译"></a>代码编译</h2><p>GCC:GNU C Compiler</p>
<p>编译器:xxx-yyy-gcc均为跨平台的交叉编译器,如arm-Linux-gcc为目标平台为arm,编译平台为Linux,编译语言为c语言的编译器。</p>
<p>如何解决各平台,如Windows、Linux、arm平台之间的文件传输问题?<br>A:Windows与Linux:共享文件夹功能<br>Windows与arm:串口的xModern协议传输文件</p>
<p>下载程序<br>rx : receive xModern<br>用串口的xModern协议来接收文件<br>如:<br>rx  smart_home</p>
<pre class="line-numbers language-none"><code class="language-none">改变可执行文件的权限
	chmod +x  smart_home<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">eXcute<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>运行可执行程序</p>
<pre class="line-numbers language-none"><code class="language-none">.&#x2F;可执行程序<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>什么是终端(terminal) ?<br>A 硬件  B 软件<br>终端是介于用户和OS内核之间的桥梁软件。它接收用户输入的命令,<br>并解析命令,提交给OS执行,并把OS执行命令的结果反馈给用户。</p>
<h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><p>几条基本的常用的linux命令:<br>(1)linux文件系统<br>linux文件系统是“树”的形式结构的。<br>绝对路径:<br>指根目录“&#x2F;”开始的路径。<br>如:<br>&#x2F;home&#x2F;gec&#x2F;1.txt</p>
<pre class="line-numbers language-none"><code class="language-none">系统认识文件是以 绝对路径 来识别的。
		相对路径:
			不以根目录&quot;&#x2F;&quot;开始的路径。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">working directory 工作目录&#x2F;当前目录
			在linux下每个进程都会有一个“当前目录”<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">如:
				假设你的当前目录 为 &#x2F;home
				此时,你可以用目录:
					gec&#x2F;1.txt  --&gt; &#x2F;home&#x2F;gec&#x2F;1.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">当前目录+相对路径 &#x3D;〉 绝对路径<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">操作系统会自动为每个目录创建两个子目录
				.&#x2F;  代表的是当前路径
				..&#x2F;  代表的是上一级路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>(2)cd<br>change directory 改变目录</p>
<pre class="line-numbers language-none"><code class="language-none">语法:
	 	cd  目录名
	 		目录名代表的是你要切换到的那个目录
	 		目录名指定可以用 绝对路径,也可以用相对路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>(3) ls<br>list  列举。列举一个目录或文件的信息</p>
<pre class="line-numbers language-none"><code class="language-none">ls  目录
	  ls
	  	列举当前目录的文件信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>(4) pwd<br>print  working directory<br>输出当前工作目录的完整的路径名</p>
<p>(5) 创建目录mkdir<br>make  directory创建目录的</p>
<p>mkdir  要创建的目录名<br>目录名可以用绝对路径指定,也可以用相对路径</p>
<p>mkdir   -p   要创建的目录名<br>-p parent 双亲<br>如果要创建的目录的父目录(父目录的父目录,…)没有,则一并创建。<br>(6) 删除文件或目录<br>rm  remove</p>
<p>rm  -rf   要删除的文件名或目录<br>(7) 创建新的空的普通文件<br>touch</p>
<p>语法:<br>touch  要创建的普通文件的文件名(可以多个,多个的话以空格隔开)</p>
<p>例子:</p>
<p>touch main.c  main.h  lcd.c lcd.h ts.c  ts.h  detect.c detect.h<br>(8) 工程编译命令<br>make<br>但是make的正确运行离不开一个配置文件 Makefile&#x2F;makefile</p>
<p>用法:<br>make clean 清除中间文件和可执行文件<br>make  自动进行编译工作<br>这一步如果没有语法错误,则会最终生成可执行文件</p>
<p>如:<br>-〉 smart_home</p>
<h1 id="LCD屏幕的使用"><a href="#LCD屏幕的使用" class="headerlink" title="LCD屏幕的使用"></a>LCD屏幕的使用</h1><p>Linux下一切皆文件,屏幕的使用同样是操作文件的过程。</p>
<h2 id="LCD屏幕原理"><a href="#LCD屏幕原理" class="headerlink" title="LCD屏幕原理"></a>LCD屏幕原理</h2><p>分辨率:800*480 480P<br>1920*1080 1080P<br>1080*720 720P<br>2K<br>4K<br>由480行 每行有800个像素点来组成</p>
<p>像素点(piexl)是什么?<br>像素点就是能显示某种颜色的店<br>在屏幕上显示图像 是不是就是给每个像素点一个颜色</p>
<p>颜色如何描述的<br>红色<br>RED ….<br>如何统一<br>各种颜色其实由三基色组成<br>red green blue</p>
<p>red的程度不一样 怎么来描述呢?<br>量化:数量化</p>
<p>read<br>*<br>**</p>
<p>read  green blue<br>255   0      0     耀世红<br>0    255      0    原谅绿<br>0     0     255    天空蓝</p>
<p>RGB:占3个字节 0xff0000</p>
<p>“透明度”<br>一个像素点由4个字节来描述的<br>ARGB:<br>A 透明度<br>0~255<br>ARGB:0x00 00 00 00 &#x3D;&#x3D;&gt; int</p>
<h2 id="Linux层次"><a href="#Linux层次" class="headerlink" title="Linux层次"></a>Linux层次</h2><p>中间层OS<br>对上应用层提供操作硬件的接口函数,并且屏蔽实现的细节<br>于是我们就有人提出在内存上开辟一段缓冲区,用来保存屏幕上的每一个像素点的颜色值,然后应用程序直接把要显示的图像的颜色值直接写入到这块内存上即可。<br>buffer至少要多大:480*800*4<br>这种缓冲区,我们在Linux下面称之为:帧缓冲 fram buffer &#x3D;&#x3D;&#x3D; fb<br>帧缓冲设备是对图像设备的一种抽象,它让上层应用不必关心具体的实现的细节,上层应用只需要在帧缓冲中填上合适的颜色值即可。<br>然后帧缓冲的驱动按一定的刷新频率,把颜色值在屏幕上正确的显示即可。以上就是帧缓冲的原理。</p>
<pre class="line-numbers language-none"><code class="language-none">6818开发板上:屏幕 &#x2F;dev&#x2F;fb0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h2><pre class="line-numbers language-none"><code class="language-none">系统IO
		标准IO
		命令man
			查看帮助文档,linux提供了API函数的帮助文档(说明文档)
			eg:
				man printf
			可选项-f 显示所有的相关的页
			查看具体那一页:直接man + 页数
			eg:
				man 3 printf
		操作文件
			打开、关闭、读、写
		a.open close
		open--打开文件
		NAME
        open, openat, creat - open and possibly create a file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">SYNOPSIS
	       #include &lt;sys&#x2F;types.h&gt;
	       #include &lt;sys&#x2F;stat.h&gt;
	       #include &lt;fcntl.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">int open(const char *pathname, int flags);
	  函数功能:打开文件
	  函数参数:
	  	pathname:文件路径名,可以是绝对路径也可以是相对路径
	  	flags:标志位,文件以什么权限打开
	  		O_RDONLY:只读 open_read_only
	  		O_WRONLY:只写
	  		O_RDWR:可读可写
	  	三个标志只能选其一
	  返回值:
	  	成功,返回一个文件描述符(&gt;0)
	  	失败,返回-1,并且errno被设备。
	  	同学    槟榔
	     0     买到了
	     -1    没买到
	     -2    被抓到了
	     -3    槟榔被吃光了
	     ....
	     errno
	     可以由perror来解释
	     NAME
perror - print a system error message<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">SYNOPSIS
	       #include &lt;stdio.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">void perror(const char *s);
	       eg:
	       	perror(&quot;binglang:&quot;);
	       在屏幕打印:
	       	槟榔:错误信息\n
	代码举例:
		int fd &#x3D; open(&quot;1.txt&quot;,O_RDWR);&#x2F;&#x2F;以可读可写打开文件
		if(fd&lt;0)
		&#123;
			perror(&quot;open fail&quot;);
			return ;
		&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">b.close
	NAME
close - close a file descriptor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">SYNOPSIS
	       #include &lt;unistd.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">int close(int fd);
	       fd:文件描述符是open的返回值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">c.read
	NAME
    read - read from a file descriptor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">SYNOPSIS
	       #include &lt;unistd.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">ssize_t read(int fd, void *buf, size_t count);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">函数功能:
		从一个已经打开的文件中读 count个字节,放到buf所指向的空间中去。
	函数参数:
		fd:
		buf:
		count:
	  PS:void* 空指针
	  PS:const C语言关键字,所修饰的变量,告诉系统不能轻易的去改变。为了提升程序健壮性。
	 函数返回值:
	 	成功,返回成功读取到字节数,文件偏移量(光标)会随之增加
	 	失败,返回-1,并且errno被设置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">d.write
		NAME
write - write to a file descriptor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">SYNOPSIS
#include &lt;unistd.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>ssize_t write(int fd, const void *buf, size_t count);<br>函数功能:<br>从buf所指向的空间里面取count个字节写到fd中去<br>函数参数:<br>fd:<br>buf:<br>count:<br>函数返回值:<br>成功,返回成功写入的字节数,文件偏移量(光标)会随之增加<br>失败,返回-1,并且errno被设置</p>
<p>e.lseek<br>NAME<br>lseek - reposition read&#x2F;write file offset</p>
<pre class="line-numbers language-none"><code class="language-none">SYNOPSIS
	       #include &lt;sys&#x2F;types.h&gt;
	       #include &lt;unistd.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">off_t lseek(int fd, off_t offset, int whence);
	      函数功能:重定位光标
	      函数参数:
	      	fd:
	      	offset:要设置的偏移量
	      	whence:定位光标
	      SEEK_SET:以文件的开头定位  offset&gt;0
          	The file offset is set to offset bytes.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">SEEK_CUR:以当前光标位置进行定位 offset可正可负
	              The file offset is set to its current location plus offset bytes.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">SEEK_END:以文件末尾进行定位 offset可正可负
	              The file offset is set to the size of the file plus offset bytes.
	    返回值:
	    	成功返回新的光标位置相对于文件开头的偏移量(单位字节)
	    	失败,返回-1,并且errno被设置
	   作业一:
	   		使用lseek来求文件大小。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">作业二:
	   		在开发板屏幕上显示德国国旗。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">作业三:
	   		在开发板屏幕上显示太极图案<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h1 id="BMP图片显示"><a href="#BMP图片显示" class="headerlink" title="BMP图片显示"></a>BMP图片显示</h1><h2 id="Linux帧缓存驱动"><a href="#Linux帧缓存驱动" class="headerlink" title="Linux帧缓存驱动"></a>Linux帧缓存驱动</h2><p>物理屏幕分辨率:<br>800*480</p>
<pre class="line-numbers language-none"><code class="language-none">屏幕由480行,且每行有800个像素点组成。
	每个像素点可以颜色一个标准的颜色:
		ARGB8888
但是每个不同的屏幕,显示时序、接口等等都不一样,
那如果这样,我应用程序如果要显示一个颜色,还要根据不同
的屏幕,去组织不同的代码,这个是不是就很麻烦。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">从应用角度来说:
		“我(应用工程师)认为,所以的显示屏都应该是一样的,
		因为我用它就是用来显示某个颜色”<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>为了实现这个:<br>Linux内核特地引入 “帧缓冲”</p>
<pre class="line-numbers language-none"><code class="language-none">在内核开辟了一个 Frame Buffer,用来保存显示屏上每一个像素
	点的颜色(从上至下,从左至右)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">应用程序只需要把准备好的颜色值数据,拷贝到frame buffer,
	然后 帧缓冲驱动,会按照一定的刷新频率、按照特定的屏幕显示
	的要求、接口、时序......把颜色值正确地显示到屏幕上去。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">对上(应用)屏蔽了具体的硬件实现细节。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<hr>
<h2 id="frame-buffer本质就是一块内存显示任何图像都是直接去操作这块内存"><a href="#frame-buffer本质就是一块内存显示任何图像都是直接去操作这块内存" class="headerlink" title="frame buffer本质就是一块内存显示任何图像都是直接去操作这块内存"></a>frame buffer本质就是一块内存<br>显示任何图像都是直接去操作这块内存</h2><p>可以通过指针去操作这个frame buffer,进而就可以通过指针去显示图像!!!</p>
<p>int *plcd; &#x2F;&#x2F;假设 让plcd指向linux内核帧缓冲的首地址</p>
<pre class="line-numbers language-none"><code class="language-none">*plcd &#x3D; 0xff0000; &#x2F;&#x2F;屏幕上第0行的第0点显示红色<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">*(plcd + 1) &#x3D; 0xff0000;&#x2F;&#x2F;屏幕上第0行的第1个点显示红色
	*(plcd + 2) &#x3D; 0xff0000;&#x2F;&#x2F;屏幕上第0行的第2个点显示红色
	...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">如果是任意的一个点(x,y)如何通过 plcd来显示颜色呢?<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">(0,0)-------------------------------&gt;x
		|
		|
		|
		|		(x,y)
		|
		|<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>*(plcd + 800*y + x) &#x3D; 0xff0000;</p>
<pre class="line-numbers language-none"><code class="language-none">void lcd_draw_point(int x, int y, int color)
	&#123;
		if (x &gt;&#x3D; 0 &amp;&amp; x &lt; 800 &amp;&amp; y &gt;&#x3D; 0 &amp;&amp; y &lt; 480)
		&#123;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>*(plcd + 800*y + x) &#x3D; color;<br>}</p>
<pre class="line-numbers language-none"><code class="language-none">&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">....
	关键点:
		如何获取linux内核帧缓冲的首地址呢?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><p>内存函数:</p>
<p>mmap: memory map</p>
<p>NAME<br>mmap, munmap - map or unmap files or devices into memory</p>
<p>SYNOPSIS<br>#include &lt;sys&#x2F;mman.h&gt;</p>
<p>mmap用来把内核和文件的内存,映射到应用程序空间。<br>目的是让应用程序通过指针直接去访问内核、驱动、文件的内容。<br>void* mmap(void *addr, size_t length, int prot,<br>int flags,   int fd, off_t offset);</p>
<p>addr: 地址,表示您要映射到哪个位置上去。<br>有人说,我怎么知道映射到哪个位置上去。<br>一般的人不知道,所以此处可以填 NULL,表示让<br>操作系统自动分配。<br>length:<br>要映射的内存区的长度,如:	800*480*4<br>prot: 映射区的权限,如下:<br>PROT_READ<br>PROT_WRITE: 可读可写<br>PROT_EXEC : excute,可执行<br>PROT_NONE<br>flags: 映射标志。<br>MAP_SHARED  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;<br>MAP_PRIVATE</p>
<p>fd :文件描述符,表示您要映射哪个文件。</p>
<p>offset:偏移量,表示您要从文件的哪个位置开始映射<br>返回值:<br>成功,返回映射区的首地址。<br>失败,返回MAP_FAILED</p>
<pre class="line-numbers language-none"><code class="language-none">munmap解映射。
int munmap(void *addr, size_t length);
addr:要解映射的地址
length:长度
返回值:
成功返回0
失败返回其他值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="BMP图片解析及显示"><a href="#BMP图片解析及显示" class="headerlink" title="BMP图片解析及显示"></a>BMP图片解析及显示</h2><p>bitmap ,位图文件, microsoft。<br>是一种无压缩的图片格式 。</p>
<p>每一张BMP图片文件 ,可以分为如下四个部分:</p>
<p>BITMAP文件头<br>14bytes</p>
<p>DIB文件头<br>40bytes<br>0x12处的4个字节</p>
<p>width:<br>int width;<br>lseek(fd, 0X12, SEEK_SET);<br>read(fd, &amp;width, 4);</p>
<pre class="line-numbers language-none"><code class="language-none">width &gt; 0
			每一行的像素点的数据是从左至右保存的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">width &lt; 0
			每一行的像素点的数据是从右至左保存的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>height:<br>0x16处的4个字节<br>int height;<br>lseek(fd, 0x16,SEEK_SET);<br>read(fd, &amp;height, 4);</p>
<pre class="line-numbers language-none"><code class="language-none">height &gt; 0
			先保存了是最底下一行的数据, 从下至上保存每一行
		height &lt; 0
			先保存了最上面一行的数据,从上至下保存每一行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>depth:<br>色深。指的是每个像素点数据所占的bits位数。<br>1, 2, 4, 8, ……。</p>
<pre class="line-numbers language-none"><code class="language-none">depth &#x3D; 24
			RGB888<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">depth &#x3D; 32
			ARGB8888<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>调色板<br>标准的图片(depth&#x3D;24 or 32),这一部分没有</p>
<p>像素数组<br>保存了每一个像素点的颜色值。</p>
<pre class="line-numbers language-none"><code class="language-none">如:
			width &gt; 0
			height &gt; 0
			depth &#x3D; 24<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">B G R (图片最左下角的那个点的颜色值)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>思考:<br>(1) 图片缩放功能</p>
<pre class="line-numbers language-none"><code class="language-none">(2) 图片显示的动画功能<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h1 id="字模"><a href="#字模" class="headerlink" title="字模"></a>字模</h1><p><img src="https://i.loli.net/2021/06/10/nyLq859cMCDaxHJ.png" alt="横向取模"></p>
<p><img src="https://i.loli.net/2021/06/10/KXglUh7IukFTo5M.png" alt="纵向取模"></p>
<p><img src="https://i.loli.net/2021/06/10/SqersaMNCzwLnBu.png" alt="纵向取模_多个字"></p>
<p><img src="https://i.loli.net/2021/06/10/1HMhlaYmOvifZXE.png" alt="字模图片"></p>
<h1 id="实现图片的动画显示效果"><a href="#实现图片的动画显示效果" class="headerlink" title="实现图片的动画显示效果"></a>实现图片的动画显示效果</h1><h1 id="线程和音乐播放"><a href="#线程和音乐播放" class="headerlink" title="线程和音乐播放"></a>线程和音乐播放</h1><h2 id="程序的运行方式"><a href="#程序的运行方式" class="headerlink" title="程序的运行方式"></a>程序的运行方式</h2><p>串行方式:<br>先把程序1执行完毕,然后再执行程序2,……。</p>
<pre class="line-numbers language-none"><code class="language-none">缺点:
		CPU利用率非常低。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">程序
			S1 输入数据
			S2 运算
			S3 写回结果<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">为了提高CPU利用率<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>并发方式<br>允许多个程序同时运行。</p>
<pre class="line-numbers language-none"><code class="language-none">为了提高CPU利用率,程序的运行采用并发的方式。
	现代操作系统为了实现程序的并发方式,特地引入进程。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">引入进程的目的是为了实现并发,让多个程序同时运行,
	请问操作系统是如何达到这个目的呢?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><p>程序:静态的概念<br>进程:动态的概念。<br>进程就一个程序的执行过程。</p>
<pre class="line-numbers language-none"><code class="language-none">Ready
	Running
	Blocking<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">进程是粗粒度的并发,
	线程是细粒度的并发。线程是进程内部一条指令执行路径。
			一个进程可以有多个线程,一个进程内部的多个线程
			共享整个进程地址空间的。
			一个进程内的线程通信 效率 要比 多个进程通信效率高。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="Linux线程创建"><a href="#Linux线程创建" class="headerlink" title="Linux线程创建"></a>Linux线程创建</h2><p>pthread: posix thread</p>
<p>NAME<br>pthread_create - create a new thread</p>
<p>SYNOPSIS<br>#include &lt;pthread.h&gt;</p>
<pre class="line-numbers language-none"><code class="language-none">pthread_t 类型是用来描述一个线程信息,如:线程id,...
       			 pthread_t的实例是用来 唯一标识一个线程的。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">int pthread_create(pthread_t *thread,
       						const pthread_attr_t *attr,
                          void *(*start_routine) (void *),
                          void *arg);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">thread: 指向的空间,用来保存线程id,
                         attr: 用来指定线程的属性,一般此处填NULL,
                         		采用默认的线程属性。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">start_routine: 函数指针,指向“线程函数”
                         arg: 将作为“线程函数”参数
                  返回值:
                  	成功返回 0
                  	失败返回 -1,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">Compile and link with -pthread.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-c" data-language="c"><code class="language-c">例子<span class="token operator">:</span>

	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h></span></span>
	     	<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">task1</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>

		<span class="token comment">//while (1)</span>
		<span class="token comment">//&#123;</span>
		     	<span class="token comment">//	&#125;</span>
	<span class="token comment">//	system("madplay  xxx.mp3");</span>
		<span class="token keyword">char</span> cmd<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

		<span class="token function">sprintf</span><span class="token punctuation">(</span>cmd<span class="token punctuation">,</span> <span class="token string">"madplay %s"</span><span class="token punctuation">,</span> mp3_file_name<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token function">system</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	     	<span class="token class-name">pthread_t</span> tid<span class="token punctuation">;</span>
	<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>

		ret <span class="token operator">=</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tid<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> task1<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token punctuation">&#123;</span>

		<span class="token punctuation">&#125;</span>

		<span class="token comment">//...</span>
	<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="获取传感器数据"><a href="#获取传感器数据" class="headerlink" title="获取传感器数据"></a>获取传感器数据</h1><h2 id="上位机和下位机"><a href="#上位机和下位机" class="headerlink" title="上位机和下位机"></a>上位机和下位机</h2><p>在项目中,经常需要与其他的外部模块进行通信。<br>通信双方,其中一方为上位机,另外一方为下位机。<br>上位机:<br>把性能比较强,大部分数据处理在上位机完成。</p>
<pre class="line-numbers language-none"><code class="language-none">下位机:
			功能比较单一,一般只负责数据采集的那一端。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="GY-39通信接口及协议"><a href="#GY-39通信接口及协议" class="headerlink" title="GY-39通信接口及协议"></a>GY-39通信接口及协议</h2><p>UART</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//串口所对应的文件名</span>
	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">COM2</span> <span class="token string">"/dev/ttySAC1"</span></span>
	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">COM3</span> <span class="token string">"/dev/ttySAC2"</span></span>
	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">COM4</span> <span class="token string">"/dev/ttySAC3"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>(1) open<br>(2) 配置串口参数</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//初始化串口</span>
<span class="token comment">//file: 串口所对应的文件名</span>
<span class="token comment">//baudrate:波特率</span>
<span class="token keyword">int</span> <span class="token function">init_serial</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">int</span> baudrate<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span> 
	<span class="token keyword">int</span> fd<span class="token punctuation">;</span>

	fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open device error:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">struct</span> <span class="token class-name">termios</span> myserial<span class="token punctuation">;</span>
	<span class="token comment">//清空结构体</span>
	<span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myserial<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> <span class="token punctuation">(</span>myserial<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//O_RDWR         </span>
	myserial<span class="token punctuation">.</span>c_cflag <span class="token operator">|=</span> <span class="token punctuation">(</span>CLOCAL <span class="token operator">|</span> CREAD<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//设置控制模式状态,本地连接,接受使能</span>
	<span class="token comment">//设置 数据位</span>
	myserial<span class="token punctuation">.</span>c_cflag <span class="token operator">&amp;=</span> <span class="token operator">~</span>CSIZE<span class="token punctuation">;</span>   <span class="token comment">//清空数据位</span>
	myserial<span class="token punctuation">.</span>c_cflag <span class="token operator">&amp;=</span> <span class="token operator">~</span>CRTSCTS<span class="token punctuation">;</span> <span class="token comment">//无硬件流控制</span>
	myserial<span class="token punctuation">.</span>c_cflag <span class="token operator">|=</span> CS8<span class="token punctuation">;</span>      <span class="token comment">//数据位:8</span>

	myserial<span class="token punctuation">.</span>c_cflag <span class="token operator">&amp;=</span> <span class="token operator">~</span>CSTOPB<span class="token punctuation">;</span><span class="token comment">//   //1位停止位</span>
	myserial<span class="token punctuation">.</span>c_cflag <span class="token operator">&amp;=</span> <span class="token operator">~</span>PARENB<span class="token punctuation">;</span>  <span class="token comment">//不要校验</span>
	<span class="token comment">//myserial.c_iflag |= IGNPAR;   //不要校验</span>
	<span class="token comment">//myserial.c_oflag = 0;  //输入模式</span>
	<span class="token comment">//myserial.c_lflag = 0;  //不激活终端模式</span>

	<span class="token keyword">switch</span> <span class="token punctuation">(</span>baudrate<span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		<span class="token keyword">case</span> <span class="token number">9600</span><span class="token operator">:</span>
			<span class="token function">cfsetospeed</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myserial<span class="token punctuation">,</span> B9600<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//设置波特率</span>
			<span class="token function">cfsetispeed</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myserial<span class="token punctuation">,</span> B9600<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token keyword">case</span> <span class="token number">115200</span><span class="token operator">:</span>
			<span class="token function">cfsetospeed</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myserial<span class="token punctuation">,</span> B115200<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//设置波特率</span>
			<span class="token function">cfsetispeed</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myserial<span class="token punctuation">,</span> B115200<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token keyword">case</span> <span class="token number">19200</span><span class="token operator">:</span>
			<span class="token function">cfsetospeed</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myserial<span class="token punctuation">,</span> B19200<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//设置波特率</span>
			<span class="token function">cfsetispeed</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myserial<span class="token punctuation">,</span> B19200<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token comment">/* 刷新输出队列,清除正接受的数据 */</span>
	<span class="token function">tcflush</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> TCIFLUSH<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/* 改变配置 */</span>
	<span class="token function">tcsetattr</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> TCSANOW<span class="token punctuation">,</span> <span class="token operator">&amp;</span>myserial<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> fd<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>(3)read&#x2F;write</p>
<p>(4)close</p>
<hr>
<pre class="line-numbers language-none"><code class="language-none">上位机                             GY39
			----------------------&gt;
			cmd(0xA5, 0x83, 0x28)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">GY39数据输出格式:<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">帧头 帧头 类型	 长度						 校验和
		0xA5 0XA5 type	 len  data1 data2 ... dataN  checksu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h1 id="触摸屏输入事件获取"><a href="#触摸屏输入事件获取" class="headerlink" title="触摸屏输入事件获取"></a>触摸屏输入事件获取</h1><h2 id="Linux输入子系统的层次"><a href="#Linux输入子系统的层次" class="headerlink" title="Linux输入子系统的层次"></a>Linux输入子系统的层次</h2><p>模块化是一个系统的属性,把一个系统分为 高内聚、低耦合的模块。<br>高内聚:把逻辑上相关的对象(概念)划分在一起<br>低耦合:减少模块间的依赖</p>
<p>模块化不是结构化分析方法特有的,面向对象的分析方法也有。<br>结构化分析方法 模块化是以子程序(子系统)为主<br>面向对象分析方法 模块化是 类和对象 划分为主。</p>
<p>linux下所有系统识别的“输入设备”,都会生成一个标准的文件接口:</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;dev&#x2F;input&#x2F;eventX(X&#x3D;0,1,2,...)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>我的输入设备对应的到底是哪个文件 ?<br>&#x2F;proc&#x2F;bus&#x2F;input&#x2F;devices<br>上面这个文件里,把每个输入设备的信息保存起来.</p>
<p>读取事件的流程:</p>
<pre class="line-numbers language-none"><code class="language-none">(1) open
	(2) read  事件结构体 struct input_event
	(3) 解析
	(4) close<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="事件结构体"><a href="#事件结构体" class="headerlink" title="事件结构体"></a>事件结构体</h2><p>struct input_event</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">input_event</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">struct</span> <span class="token class-name">timeval</span> time<span class="token punctuation">;</span> <span class="token comment">//事件发生的时间</span>
		     __u16 type<span class="token punctuation">;</span>
		     		type代表事件的类型<span class="token punctuation">,</span>
		     			EV_KEY   按键类型

		     			EV_REL  relative 相对事件<span class="token punctuation">,</span>如<span class="token operator">:</span> 鼠标
		     					相对于上一个点的位移<span class="token punctuation">(</span>x轴和y轴<span class="token punctuation">)</span>

		     			EV_ABS  absolute 绝对事件<span class="token punctuation">,</span>如<span class="token operator">:</span> 触摸屏事件
		     					当前点的绝对坐标


			__u16 code<span class="token punctuation">;</span>
					根据type的不同<span class="token punctuation">,</span>code含义也不同。
					<span class="token keyword">if</span> type <span class="token operator">==</span> EV_KEY<span class="token punctuation">,</span> 
						code就是相应按键的键值
							 KEY_A
							 KEY_B
							 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
							 BTN_TOUCH 

					<span class="token keyword">if</span> type <span class="token operator">==</span> EV_ABS<span class="token punctuation">,</span> 
						code就是相应的绝对坐标
							ABS_X  x轴事件
							ABS_Y  y轴事件
							ABS_PRESSURE  压力事件


			__s32 value<span class="token punctuation">;</span>
				 根据type的不同<span class="token punctuation">,</span>value含义也不同
				 	<span class="token keyword">if</span> type <span class="token operator">==</span> EV_KEY
				 		value  <span class="token number">1</span>  按下
				 		value  <span class="token number">0</span>  弹起

				 	<span class="token keyword">if</span>  type <span class="token operator">==</span> EV_ABS
				 		<span class="token keyword">if</span> code <span class="token operator">==</span> ABS_X 
				 			value X轴的坐标值

				 		<span class="token keyword">if</span> code <span class="token operator">==</span> ABS_Y
				 			value  Y轴的坐标值

				 		<span class="token keyword">if</span> code <span class="token operator">==</span> ABS_PRESSSURE
				 			value  压力值
				 				<span class="token operator">></span><span class="token number">0</span>  触摸屏按下
				 				<span class="token operator">=</span><span class="token number">0</span>  弹起
		<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="Linux灯光驱动调用"><a href="#Linux灯光驱动调用" class="headerlink" title="Linux灯光驱动调用"></a>Linux灯光驱动调用</h1><h2 id="驱动是什么"><a href="#驱动是什么" class="headerlink" title="驱动是什么?"></a>驱动是什么?</h2><p>A 硬件   B 软件</p>
<p>应用程序是也是软件。</p>
<p>驱动是操作硬件的代码。驱动层次位于应用与硬件之间。<br>驱动对上提供操作硬件的接口,并且需要向应用屏蔽硬件<br>实现的细节。 驱动对下(硬件)检测&#x2F;监测硬件上的改变或<br>状态的变化,并向上报告其状态。</p>
<p>驱动与应用程序有什么区别?</p>
<p>裸机驱动<br>BSP驱动<br>linux驱动<br>windows驱动<br>……<br>在不同的平台下写驱动,框架及方法有不一样的。</p>
<pre class="line-numbers language-none"><code class="language-none">裸机驱动:
		不跑操作系统。
		你想怎么操作硬件,想提供什么接口给应用,都由你来写。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">linux&#x2F;widows驱动:
		你必须按照linux&#x2F;windows定义的框架,定义好的接口,去实现。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="驱动控制灯光"><a href="#驱动控制灯光" class="headerlink" title="驱动控制灯光"></a>驱动控制灯光</h2><p>open<br>read&#x2F;write&#x2F;ioctl&#x2F;….<br>close</p>
<p>加载驱动:<br>insmod   kobject_led.ko</p>
<p>卸载驱动:<br>rmmod   kobject_led.ko</p>
<p>一旦加载成功,在开发板目录<br>&#x2F;sys&#x2F;kernel&#x2F;gec_ctrl&#x2F;<br>生成<br>led_d7<br>led_d8<br>led_d9<br>led_d10<br>led_all<br>beep</p>
<pre class="line-numbers language-none"><code class="language-none">控制 led_d7
		open(&quot;&#x2F;sys&#x2F;kernel&#x2F;gec_ctrl&#x2F;led_d7&quot;, O_RDWR)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">int on &#x3D; 1; &#x2F;&#x2F;写1到文件表示 写
		write(fd, &amp;on,  4);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">on &#x3D; 0; &#x2F;&#x2F;写0到文件表示 关
		write(fd, &amp;on, 4);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">[root@GEC6818 &#x2F;mnt]# mount -t nfs 192.168.3.16:&#x2F;mnt&#x2F;hgfs &#x2F;mnt -o nolock &#x2F;&#x2F;要注意虚拟机文件的权限问题<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="https://img2020.cnblogs.com/blog/2228564/202012/2228564-20201203204525247-456551250.png" alt="img"></p>
<p>挂载成功,现在主机,虚拟机,开发板共享了同一个目录。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>嵌入式开发</tag>
        <tag>物联网</tag>
        <tag>ARM</tag>
      </tags>
  </entry>
  <entry>
    <title>现代通信原理笔记</title>
    <url>/2020/091712074.html</url>
    <content><![CDATA[<h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><h2 id="信息及其度量"><a href="#信息及其度量" class="headerlink" title="信息及其度量"></a>信息及其度量</h2><h3 id="消息与信息"><a href="#消息与信息" class="headerlink" title="消息与信息"></a>消息与信息</h3><p><strong>消息</strong>:包含信息的事物</p>
<p><strong>信息</strong>:消息中包含的有效内容</p>
<p>信息具有不确定性</p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p><strong>信号</strong>是消息的载体,是一种电波形</p>
<p>信号分为<strong>模拟信号</strong>(连续信号)和<strong>数字信号</strong>(离散信号)</p>
<h4 id="模拟信号"><a href="#模拟信号" class="headerlink" title="模拟信号"></a>模拟信号</h4><p>模拟信号占有频带一般都比较窄,其频带利用率较高,缺点是抗干扰能力差,不易保密,设备元器件不易大规模集成。</p>
<h4 id="数字信号"><a href="#数字信号" class="headerlink" title="数字信号"></a>数字信号</h4><p>比模拟信号占据更宽的系统频带</p>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>1.抗干扰、抗噪声性能好</p>
<p>2.差错可控</p>
<p>3.易加密</p>
<p>4.数字通信设备和模拟通信设备相比,设计和制造更容易,体积更小,重量更轻</p>
<p>5.数字信号可以通过信源编码进行压缩,以减少冗余度,提高信道利用率。</p>
<p>6.易与现代技术相结合</p>
<h3 id="信息量"><a href="#信息量" class="headerlink" title="信息量"></a>信息量</h3><p>信息量与消息的种类、特定内容及重要程度无关,仅仅与消息中包含的不确定度有关。消息发生的概率越小,该消息包含的信息量越大。消息发生的概率趋近于0,则其信息量趋近于无穷大。</p>
<p>信息论中,消息所含的信息量I与消息X出现的概率P(x)的关系为:</p>
<p>$$<br>I&#x3D;{log_a{\frac1{P(x)}}}&#x3D;-{log_a{P(x)}}\<br>信息量的单位由对数底的取值决定\<br>a&#x3D;2时单位为“比特”\<br>a&#x3D;e时单位为“奈特”\<br>a&#x3D;10时单位为“哈特”\<br>通常采用“比特”作为信息量的实用单位<br>$$</p>
<p>I代表两种含义:当事件X发送以前,表示事件X发送的不确定性;当事件X发生以后,表示事件X所含有的信息量。</p>
<p>设离散信息源是一个由n个符号组成的集合,符号集中的每个字符Xi在消息中是按一定概率P(xi)独立出现的,又设符号集中各符号出现的概率为<br><img src="https://i.loli.net/2020/09/18/HXBSv46tu9WnDxG.png" alt="符号集中各符号出现的概率"><br>改变信源每个符号所含的信息量的统计平均值,即平均信息量为:<br><img src="https://i.loli.net/2020/09/18/kNjnmK9FcaD14xO.png" alt="平均信息量"></p>
<p>连续消息的信息量可以用概率密度来描述,可以证明连续消息的平均信息量(相对熵)为:<br><img src="https://i.loli.net/2020/09/18/NWtygFpTISUoqhV.png" alt="连续消息的平均信息量"><br>f(x)是连续消息出现的概率密度</p>
<h2 id="通信系统"><a href="#通信系统" class="headerlink" title="通信系统"></a>通信系统</h2><h3 id="通信系统基本模型"><a href="#通信系统基本模型" class="headerlink" title="通信系统基本模型"></a>通信系统基本模型</h3><p><img src="https://i.loli.net/2020/09/18/6sGpvS4tWlzIw89.png" alt="通信系统的基本模型">信源:将消息转换为原始电信号(基带信号)。<br>发送设备:将输入的电信号变成适合信道传输的形式(调制、滤波、放大、发射)包含信源编码和信道编码。<br>信道:将信号从发送设备向接收设备传送的物理媒质,包含有线信道和无线信道。<br>接收设备:从带干扰的接收信号中恢复出相应的原始电信号(解调、滤波、抑制噪声)。<br>受信者(信宿):将原始电信号转换成为消息。</p>
<p><strong>信源编码</strong>:可分为压缩编码和保密编码,提高数字信号传输的有效性,信源编码器输出的是信息码元,<strong>话音</strong>和<strong>图像</strong>压缩编码都是信源编码器完成的<br><strong>信道编码</strong>(纠错编码):提高数字信号传输的可靠性,其基本做法是在信息码组中按一定的规则附加一些监督码元,以使接收端根据相应的规则进行检错和纠错<br><strong>数字调制</strong>:将所传输的数字序列的频谱搬移到合适信道传输的频带范围内,使其适应信道传输的要求,基本的调制方式有幅移键控(ASK)、频移键控(FSK)和相移键控(PSK)<br><strong>加性干扰</strong>:噪声叠加在信号上<br><strong>乘性干扰</strong>:<strong>多径传播</strong>是一种是信号质量降低的干扰,多径传播是信号振幅随机起伏的现象称为<strong>衰落</strong>。将这种衰落称为乘性干扰或乘性噪声。</p>
<p>在接收设备端的原始电信号还能称为基带信号吗?不是,带有噪声</p>
<h3 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h3><h4 id="1-按信息传输的方向与时间关系划分通信方式"><a href="#1-按信息传输的方向与时间关系划分通信方式" class="headerlink" title="1.按信息传输的方向与时间关系划分通信方式"></a>1.按信息传输的方向与时间关系划分通信方式</h4><p>对于点对点之间的通信,按信息传送的方向与时间的关系,通信方式可分为单工通信,半双工通信及全双工通信<br>单工通信:广播、遥控、无线寻呼等<br>半双工通信:无线对讲机、收发报机等<br>全双工通信:电话、计算机网络通信等</p>
<p><img src="https://i.loli.net/2020/09/18/LuIPXo3K6DJkdN1.png" alt="通信方式示意图"></p>
<h4 id="2-按数字信号码元排列方式划分通信方式"><a href="#2-按数字信号码元排列方式划分通信方式" class="headerlink" title="2.按数字信号码元排列方式划分通信方式"></a>2.按数字信号码元排列方式划分通信方式</h4><p>在数字通信中按照数字码元排列顺序的方式不同,可将通信方式分为串行通信和并行通信。</p>
<p><img src="https://i.loli.net/2020/09/18/1qri29ZyIgY4uoV.png" alt="串并行通信方式"></p>
<h5 id="并行通信"><a href="#并行通信" class="headerlink" title="并行通信"></a>并行通信</h5><p>将代表信息的数字信号码元序列分割成两路或两路以上的数字信号序列同时在信道上传输。</p>
<p>优点:速度快、节省传输时间,但需占用频带宽,设备复杂,成本高,故较少采用,适用于短距离通信。</p>
<h5 id="串行通信"><a href="#串行通信" class="headerlink" title="串行通信"></a>串行通信</h5><p>将代表信息的数字信号码元序列按照时间顺序一个接一个地传输</p>
<p>适用于远距离传输</p>
<h4 id="3-按网络结构划分通信方式"><a href="#3-按网络结构划分通信方式" class="headerlink" title="3.按网络结构划分通信方式"></a>3.按网络结构划分通信方式</h4><p>线型、星型、树型、环形等等</p>
<h3 id="通信系统的分类"><a href="#通信系统的分类" class="headerlink" title="通信系统的分类"></a>通信系统的分类</h3><h4 id="1-按传输媒质分类"><a href="#1-按传输媒质分类" class="headerlink" title="1.按传输媒质分类"></a>1.按传输媒质分类</h4><p>有线通信系统和无线通信系统</p>
<h4 id="2-按信号的特征分"><a href="#2-按信号的特征分" class="headerlink" title="2.按信号的特征分"></a>2.按信号的特征分</h4><p>模拟通信系统和数字通信系统</p>
<h4 id="3-按工作频段分类"><a href="#3-按工作频段分类" class="headerlink" title="3.按工作频段分类"></a>3.按工作频段分类</h4><p>长波通信、中波通信、短波通信、微波通信</p>
<p><img src="https://i.loli.net/2020/09/18/hw6R9Vznq5vaC4g.png" alt="通信频段、常用传输媒质及主要用途"></p>
<p>工作波长和频率的换算公式为:</p>
<p>$$<br>\lambda&#x3D;\frac cf&#x3D;\frac{3x10^8}f\<br>其中\lambda为工作波长(m),f为最高工作频率(Hz),c为光速(m&#x2F;s)<br>$$</p>
<h4 id="4-按调制方式分类"><a href="#4-按调制方式分类" class="headerlink" title="4.按调制方式分类"></a>4.按调制方式分类</h4><p>基带传输系统和频带(调制)传输系统</p>
<h4 id="5-按通信业务类型分类"><a href="#5-按通信业务类型分类" class="headerlink" title="5.按通信业务类型分类"></a>5.按通信业务类型分类</h4><p>电报通信系统、电话通信系统、数据通信系统和图像通信系统</p>
<h4 id="6-按信号复用方式分类"><a href="#6-按信号复用方式分类" class="headerlink" title="6.按信号复用方式分类"></a>6.按信号复用方式分类</h4><p>频分复用(FDM)、时分复用(TDM)、码分复用(CDM)通信系统</p>
<h3 id="模拟通信系统"><a href="#模拟通信系统" class="headerlink" title="模拟通信系统"></a>模拟通信系统</h3><p>传输模拟信号的系统,在信道中传输模拟信号。</p>
<p><img src="https://i.loli.net/2020/09/18/KIcStB6ZNRGlQiy.png" alt="模拟通信系统的模型"><br>发信人的语音信息经过变换器转变成电信号(<strong>模拟信源</strong>),然后由调制器放大后在信道中传输<br>原始电信号(基带信号)进行调制是为了<strong>提高频带利用率</strong>,使多路信号同时在信道中传输。<br>在接收端,经过解调器和你变换器还原成语音信息。</p>
<h3 id="数字通信系统"><a href="#数字通信系统" class="headerlink" title="数字通信系统"></a>数字通信系统</h3><p><img src="https://i.loli.net/2020/09/18/j2UzF1kDsOgeHcn.png" alt="image-20200918110926136"><br><strong>数字频带传输通信系统</strong>:;利用数字信号来传递信息的通信系统,分为数字频带传输通信系统和数字基带传输通信系统。<br>数字通信系统有一个非常重要的控制单元:同步系统,可以使通信系统的收、发两端或整个通信系统,以精度很高的时钟提供定时,以使系统数据流能与发送端同步、有序而准确地接受和恢复原信息<br>变换器:将信息转换成数字基带信号</p>
<p><img src="https://i.loli.net/2020/09/18/hs3LjT6tBmb9AU4.png" alt="数字基带传输系统模型"><br><strong>数字基带传输通信系统</strong>:与频带传输通信系统对应,把没有调制&#x2F;解调器的数字通信系统称为数字基带传输通信系统<br>基带信号形成器:可能包含编码器、加密器以及波形变换等<br>接收滤波器:可能包含译码器、解密器等</p>
<h2 id="通信系统的性能指标"><a href="#通信系统的性能指标" class="headerlink" title="通信系统的性能指标"></a>通信系统的性能指标</h2><p>评价通信系统优劣的主要性能指标是系统的有效性和可靠性</p>
<p>有效性:指消息传输的“速度”问题<br>可靠性:指消息传输的“质量”问题</p>
<p>二者经常矛盾,反比</p>
<h3 id="模拟通信系统的性能指标"><a href="#模拟通信系统的性能指标" class="headerlink" title="模拟通信系统的性能指标"></a>模拟通信系统的性能指标</h3><p>模拟通信系统的有效性指标用所传信号的有效传输带宽来表征。当信道容许传输带宽一定,而进行多路频分复用时,每路信号所需的有效带宽越窄,信道内复用的路数越多</p>
<p><strong>信道复用的程度越高,信号传输的有效性越好</strong></p>
<p>信号的有效传输带宽与系统采用的调制方法有关</p>
<p>模拟通信系统的可靠性指标用整个通信系统的输出信噪比来衡量。信噪比是信号的平均功率S与噪声的平均功率N之比。<em>信噪比越高,说明噪声对信号的影响越小。显然,信噪比越高,通信质量就越好</em>。</p>
<p>输出信噪比一方面与信道内噪声的大小和信号的功率有关,同时又<em>和调制方式有很大关系</em>。例如宽带调频系统的有效性不如调幅系统,但是调频系统的可靠性往往比调幅系统好。</p>
<h3 id="数字通信系统的性能指标"><a href="#数字通信系统的性能指标" class="headerlink" title="数字通信系统的性能指标"></a>数字通信系统的性能指标</h3><h4 id="有效性指标"><a href="#有效性指标" class="headerlink" title="有效性指标"></a>有效性指标</h4><p>数字通信系统的有效性指标用传输速率和频带利用率来表征。</p>
<h5 id="传输速率"><a href="#传输速率" class="headerlink" title="传输速率"></a>传输速率</h5><p>传输速率有三种表示方式:</p>
<p>$$<br>码元传输速率R_B\信息传输速率R_b\消息速率R_M<br>$$</p>
<h6 id="码元传输速率"><a href="#码元传输速率" class="headerlink" title="码元传输速率"></a><strong>码元传输速率</strong></h6><p>简称传码率,又称符号速率等。它表示单位时间内传输码元的数目,单位是波特(Baud),记为B。<br>它表示单位时间内传输码元的数目,单位是波特(Baud),记为B。<br>例如,若1秒内传2400个码元,则传码率为2400B。<br>数字信号有多进制和二进制之分,但码元速率与进制数无关,只与传输的码元长度T有关</p>
<p><img src="https://i.loli.net/2020/10/02/lADQnE2KjhVryNU.png" alt="符号(码元)传输速率"></p>
<h6 id="信息传输速率"><a href="#信息传输速率" class="headerlink" title="信息传输速率"></a><strong>信息传输速率</strong></h6><p>简称传信率,又称比特率等。它是指系统每秒钟传送的信息量,单位是比特&#x2F;秒,常用符号“bit&#x2F;s、bps或b&#x2F;s”表示<br>它表示单位时间内传递的平均信息量或比特数</p>
<p>$$<br>在N进制下,设信息速率为R_b(bit&#x2F;s),码元速率为R_{BN}(Baud),由于每个码元或符号通常\都含有一定比特的信息量,因此码元速率和信息速率有确定的关系,即:\<br>R_b&#x3D;R_{BN}H(x)\ \ \ \ \ (bit&#x2F;s)\<br>式中,H(x)为信源中每个符号所含的平均信息量(熵)。当离散信源的每一符号等概率出现\时,熵有最大值为{log_2N}(bit&#x2F;符号),信息速率也达到最大,即:\<br>R_b&#x3D;R_{BN}{log_2N}\ (bit&#x2F;s)\<br>R_{BN}&#x3D;\frac{R_b}{log_2N}\ (Baud)<br>$$</p>
<h6 id="消息速率"><a href="#消息速率" class="headerlink" title="消息速率"></a><strong>消息速率</strong></h6><p>单位时间内传输的消息数目。例如,传输中文文件时,消息速率的单位是“字&#x2F;秒”</p>
<h6 id="码元速率与信息速率的关系"><a href="#码元速率与信息速率的关系" class="headerlink" title="码元速率与信息速率的关系"></a>码元速率与信息速率的关系</h6><p>每个码元或符号通常都含有一定bit数的信息量,因此码元速率和信息速率有确定的关系</p>
<p><img src="https://i.loli.net/2020/10/02/yPuq1p6LjRAflwv.png" alt="码元速率与信息速率的关系"></p>
<p>H为信源中每个符号所含的平均信息量(熵)<br><strong>M进制、等概率</strong>传输时,熵有最大值,信息速率也达到最大</p>
<p><img src="https://i.loli.net/2020/10/02/ZrAknGNFxgo9pj7.png" alt="![](https://i.loli.net/2020/10/02/ZrAknGNFxgo9pj7.png)"></p>
<p>码元速率为1200B<br>采用八进制(M&#x3D;8)时,信息速率为3600b&#x2F;s;<br>采用二进制(M&#x3D;2)时, 信息速率为1200b&#x2F;s,<br><em>二进制的码元速率和信息速率在数量上相等,有时简称它们为数码率。</em></p>
<h4 id="可靠性指标"><a href="#可靠性指标" class="headerlink" title="可靠性指标"></a>可靠性指标</h4><h5 id="错误率"><a href="#错误率" class="headerlink" title="错误率"></a>错误率</h5><p>衡量数字通信系统可靠性的指标是差错率, 常用误码率和误信率表示。<br>误码率(码元差错率Pe )是指发生差错的码元数在传输总码元数中所占的比例,更确切地说,误码率是码元在传输系统中被传错的概率,即</p>
<p><img src="https://i.loli.net/2020/10/02/z6Wk1lIQCRxGocK.png" alt="误码率"></p>
<p>误信率(信息差错率Pb )是指发生差错的比特数在传输总比特数中所占的比例, 即</p>
<p><img src="https://i.loli.net/2020/10/02/6AWBHUE1yjqcMTl.png" alt="误信率"></p>
<p>实际中分析误信率(二进制就是误码率),可用</p>
<p><img src="https://i.loli.net/2020/10/02/Dri6m3KL8IwaSPE.png" alt="实际中分析误信率"><br>Pe与Pb的关系:<br>二进制—— Pb&#x3D; Pe<br>M进制—— Pb&lt; Pe</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>现代通信原理</tag>
      </tags>
  </entry>
  <entry>
    <title>考研英语翻译笔记</title>
    <url>/2021/082329226.html</url>
    <content><![CDATA[<p>在考研翻译中,碰到代词:</p>
<p>1.可以尝试直接对应为汉语代词,前提是译文要通顺。</p>
<p>2.如果不通顺,则需要指代明确,尽可能地用指代到的名词翻译。这时,需要往前看,根据“就近和一致原则”来确定。</p>
<p>3.万不得已,可以直接用“这、这种情况、这种说法、这种观点”等来翻译</p>
<p>通顺——是最大的控制原则:</p>
<p>1.直接对应——适合第一、二人称</p>
<p>2.指代明确——第三人称代词,要小心(they,their,them,it,this,that)</p>
<p>3.用“这、这种情况&#x2F;观点&#x2F;看法”——It,This,That</p>
<p>常考词:</p>
<p>those有“那些人”的意思</p>
<p>assume假定;猜想;认为</p>
<p>believe相信;认为</p>
<p>believe…in信仰</p>
<p>assert断言</p>
<p>claim要求;主张;声称;索取;申领;夺取</p>
<p>maintain维持;保持;主张</p>
<p>accept接受</p>
<p>contend坚持说</p>
<p>argue辩论说;争论说</p>
<p>prove证明</p>
<p>validate证明;验证</p>
<p>demonstrate证明; 证实; 论证; 说明; 表达; 表露; 表现;</p>
<p>state陈述;说明</p>
<p>point out指出</p>
<p>be convinced that坚信;认为</p>
<p>There be句型:</p>
<p>人们(我们、大家)对……有……</p>
<p><img src="https://i.loli.net/2021/08/17/oKmGMqkduflxhFQ.png" alt="image-20210817112839446"></p>
<p><img src="https://i.loli.net/2021/08/17/CrPtgJoB9EbWVxp.png" alt=" "></p>
<p><img src="https://i.loli.net/2021/08/17/qG1spc2feE3tawP.png" alt="image-20210817095728409"></p>
<p><img src="https://i.loli.net/2021/08/17/QfT2kIrmweVYA7u.png" alt="image-20210817095854382"></p>
<p><img src="https://i.loli.net/2021/08/23/OTxECsBScdMHQ6i.png" alt="image-20210823145022585"></p>
<p><img src="https://i.loli.net/2021/08/17/FnQr7XMUDdEohHu.png" alt="image-20210817100234121"></p>
<p><img src="https://i.loli.net/2021/08/17/7bt2Ie8VmN3GTyL.png" alt="image-20210817100453132"></p>
<p><img src="https://i.loli.net/2021/08/23/oVMRWeHnjvBiQts.png" alt="image-20210823144947655"></p>
<p><img src="https://i.loli.net/2021/08/17/FkMHaIshBt16L2u.png" alt="image-20210817124132516"></p>
<p><img src="https://i.loli.net/2021/08/17/5WYBRwQCAFiJSX1.png" alt="image-20210817124448067"></p>
<p><img src="https://i.loli.net/2021/08/17/myFVkjlzWo9Qqaf.png" alt="image-20210817124522371"></p>
<p><img src="https://i.loli.net/2021/08/17/AdFNT2hZKYLugvj.png" alt="image-20210817125833283"></p>
<p><img src="https://i.loli.net/2021/08/17/bctQNhBHfzeZjSu.png" alt="image-20210817125856517"></p>
<p><img src="https://i.loli.net/2021/08/17/Xdn1QlZiRNFBe92.png" alt="image-20210817130015387"></p>
<p><img src="https://i.loli.net/2021/08/17/EkxyoOfraPKtVCL.png" alt="image-20210817151023282"></p>
<p><img src="https://i.loli.net/2021/08/17/2i4q8EwjXzWOJaS.png" alt="image-20210817151538185"></p>
<p><img src="https://i.loli.net/2021/08/17/gws5vyhdDlAVHME.png" alt="image-20210817151653872"></p>
<p><img src="https://i.loli.net/2021/08/17/GiaCysjM12fpD3c.png" alt="image-20210817151920134"></p>
<p><img src="https://i.loli.net/2021/08/17/FwCWvUabtzoi235.png" alt="image-20210817152053701"></p>
<p><img src="https://i.loli.net/2021/08/17/lRNWFgMXn8DGbhA.png" alt="image-20210817152317923"></p>
<p><img src="https://i.loli.net/2021/08/17/wZkbRajOPAflVGD.png" alt="image-20210817152514503"></p>
<p><img src="https://i.loli.net/2021/08/19/5kFy8Q3T2ASRv6E.png" alt="image-20210819101129843"></p>
<p><img src="https://i.loli.net/2021/08/19/3THSrn4ieAjZ9bw.png" alt="image-20210819101220088"></p>
<p>taken 人们认为</p>
<p><img src="https://i.loli.net/2021/08/19/SMvBZzK2dQ4Aqbf.png" alt="image-20210819101238022"></p>
<p><img src="https://i.loli.net/2021/08/21/ZJtHFw2lQjA9GYR.png" alt="image-20210821183807484"></p>
<p><img src="https://i.loli.net/2021/08/21/pFE1KNOhSTaBe6Q.png" alt="image-20210821183732049"></p>
<p><img src="https://i.loli.net/2021/08/19/QB2cH9xlZLirmJ4.png" alt="image-20210819110124297"></p>
<p><img src="https://i.loli.net/2021/08/19/HzI2iveLUOM6rtZ.png" alt="image-20210819111452246"></p>
<p><img src="https://i.loli.net/2021/08/19/kumdYiJpq62BfoR.png" alt="image-20210819112001453">取决于</p>
<p><img src="https://i.loli.net/2021/08/19/t841zPu6NbyaoHC.png" alt="image-20210819173012098"></p>
<p><img src="https://i.loli.net/2021/08/19/2i4cR1KzPQAJkLS.png" alt="image-20210819173214426"></p>
<p>-ing出现在句子开头,可能是表原因&#x2F;伴随</p>
<p><img src="https://i.loli.net/2021/08/19/AO3c256BprweyWF.png" alt="image-20210819175123955"></p>
<p><img src="https://i.loli.net/2021/08/20/YSWj4m1OEet6xQ9.png" alt="image-20210820094858454"></p>
<p><img src="https://i.loli.net/2021/08/20/JXnB4TUGWuvKFC1.png" alt="image-20210820095018377"></p>
<p><img src="https://i.loli.net/2021/08/20/tCqoXOfLYacbiAD.png" alt="image-20210820112211016"></p>
<p><img src="https://i.loli.net/2021/08/20/ztswAONDpQfu9l6.png" alt="image-20210820102521124"></p>
<p><img src="https://i.loli.net/2021/08/20/tCqoXOfLYacbiAD.png"></p>
<p><img src="https://i.loli.net/2021/08/20/RaY4OEjkGPhfwdK.png" alt="image-20210820114447576"></p>
<p><img src="https://i.loli.net/2021/08/20/l8EOTXZwrDdKN4J.png" alt="image-20210820114658369"></p>
<p><img src="https://i.loli.net/2021/08/20/2n5cm84AlrxbKBI.png" alt="image-20210820114938932"></p>
<p><img src="https://i.loli.net/2021/08/20/bmg64ItlS8zOMuk.png" alt="image-20210820115054928"></p>
<p><img src="https://i.loli.net/2021/08/20/IZwqt1BN64vOfm7.png" alt="image-20210820115119600"></p>
<p><img src="https://i.loli.net/2021/08/20/9Nrtz6SUFnhRKoV.png" alt="image-20210820115330598"></p>
<p><img src="https://i.loli.net/2021/08/20/1OvF8aErdybK2iP.png" alt="image-20210820115340842"></p>
<p>take root深入人心;根深蒂固</p>
<p><img src="https://i.loli.net/2021/08/21/bB1VtXk94MnRZwQ.png" alt="image-20210821170135509"></p>
<p><img src="https://i.loli.net/2021/08/21/uoJIDtz1sWHYPve.png" alt="image-20210821170223722"></p>
<p>in view of the fact that &#x3D; because</p>
<p><img src="https://i.loli.net/2021/08/21/TPvAIbGH76sxC9j.png" alt="image-20210821170541115"></p>
<p><img src="https://i.loli.net/2021/08/21/2XxqRnlEaUWpdut.png" alt="image-20210821172055226"></p>
<p>行为科学之所以发展缓慢,</p>
<p>三个微小错误(中文错别字)-&gt;0.5分</p>
<p>item物品;商品;项目;条款;依据;细节</p>
<p><img src="https://i.loli.net/2021/08/21/hevzO4EHXGaRgsn.png" alt="image-20210821174011433"></p>
<p>my answer :</p>
<p>因为我们对于他们的首要任务是让他们能够分享在日常生活中我们没能考虑到的问题,我们是否正在形成安全能力的权力。</p>
<p>revision:</p>
<p>既然我们对年轻人的主要任务是是他们在日常生活中懂得分享,那么我们禁不住得会去思考,我们是否具备确保他们获得这种能力的力量</p>
<p>business不能翻译为与商业、交易、业务相关的意思,要和them指代的内容搭配<br>business-&gt;&gt;行业、领域、责任、业务、生意、贸易</p>
<p>share in a common life:</p>
<p><img src="https://i.loli.net/2021/08/21/2MxoSf3hIRvKPTs.png" alt="image-20210821174828440"></p>
<p>can not help doing 禁不住做某事、情不自禁做某事</p>
<p><img src="https://i.loli.net/2021/08/21/yYGFd8iwcx4DrJo.png" alt="image-20210821175046567"></p>
<p>we在句子中一定是做主语,断句点</p>
<p><img src="https://i.loli.net/2021/08/21/akuZroEUzReOH5T.png" alt="image-20210821175630091"></p>
<p><img src="https://i.loli.net/2021/08/21/3Gw2fHeV7FU6PSy.png" alt="image-20210821175639679"></p>
<p><img src="https://i.loli.net/2021/08/21/vGD7iqgXLNuO52V.png" alt="image-20210821175729418"></p>
<p>through:通过;因为,由于;经历</p>
<p><img src="https://i.loli.net/2021/08/21/T1uIXZhzn3BmrQ8.png" alt="image-20210821175856401"></p>
<p>my translation:</p>
<p>因为<strong>群聊</strong>的显著发展,各地的人们正在感受新的<strong>想法</strong>,接触新的风俗和思想,而由于以上原因,政府通常被迫开始进一步的变革。</p>
<p>revision:</p>
<p>mass communication 大众传媒、大众通讯</p>
<p>wants 想要-&gt;需求,需要</p>
<p>be exposed to 接触;接受;面对</p>
<p>ideas 观点</p>
<p>be forced to 不得不….</p>
<p>still在比较级前,加强语气,可以不翻译</p>
<p>考研翻译原则:直译优先,本意优先</p>
<p>correct translation:</p>
<p>由于大众通讯的显著发展,各地的人们正感受到新的需求,接触到新的习俗和观点,然而,由于上述原因,政府通常不得不采取更进一步的革新</p>
<p><img src="https://i.loli.net/2021/08/21/VOSnLXR2hFEWPCJ.png" alt="image-20210821182152370"></p>
<p><img src="https://i.loli.net/2021/08/21/e3w4niqXEONZcb7.png" alt="image-20210821182355598"></p>
<p><img src="https://i.loli.net/2021/08/21/eWj5rcaygNBYJGz.png" alt="image-20210821182516066"></p>
<p><img src="https://i.loli.net/2021/08/21/f3lj1VSxJdLZUoa.png" alt="image-20210821182539499"></p>
<p><img src="https://i.loli.net/2021/08/21/6ExwpWsAm7LbHaU.png" alt="image-20210821182633534"></p>
<p>&#x3D;although</p>
<p>以上这些词:前用表“虽然”,后用表“但是”,从句一般翻译到主句前面。</p>
<p><img src="https://i.loli.net/2021/08/21/oh8iP2SGEJOBslL.png" alt="image-20210821182723468"></p>
<p><img src="https://i.loli.net/2021/08/21/bf1iujKSpaYQlhV.png" alt="image-20210821182743404"></p>
<p>my translation:</p>
<p>尽管律师的意见和反应可能会影响报道,但记者们最好依靠自己的关键想法并做出自己的判断。</p>
<p>revision:</p>
<p>notion 认识;观念</p>
<p>notion of …  -&gt; 对…的认识</p>
<p>correct translation:</p>
<p>尽管来自律师的意见和反馈可能会加强报道的质量,但对于记者而言,更可取的是,依靠自己的价值观(对重要性的认识)并做出自己的判断。</p>
<p><img src="https://i.loli.net/2021/08/21/BVx6PQSzKLgO5ov.png" alt="image-20210821184450378"></p>
<p><img src="https://i.loli.net/2021/08/21/o9zRGOqkxE3neBF.png" alt="image-20210821184540357"></p>
<p>上面这些没考过</p>
<p><img src="https://i.loli.net/2021/08/21/Z53BcqzDvx4ypVo.png" alt="image-20210821184650687"></p>
<p><img src="https://i.loli.net/2021/08/21/jViSkboG13rCEYP.png" alt="image-20210821184717594"></p>
<p><img src="https://i.loli.net/2021/08/21/IJLBqpks5eaMj6T.png" alt="image-20210821184747774"></p>
<p><img src="https://i.loli.net/2021/08/21/ehbi4vxLR8aDAgt.png" alt="image-20210821184848519"></p>
<p><img src="https://i.loli.net/2021/08/21/YJCz6F78uLOgrc5.png" alt="image-20210821184906566"></p>
<p>my translation:</p>
<p>如果<strong>这个</strong>小热点像期望的那样,那将是<strong>另一个</strong>科学<strong>思想</strong>的胜利,是被称为宇宙膨胀理论的大爆炸的改进&#x2F;提升。</p>
<p>revision:</p>
<p>yet another 中yet表强调</p>
<p>hot pot-&gt;火锅</p>
<p>correct translation:</p>
<p>如果这些小热点看上去如预期那样,那将是又一科学理论的胜利及更完美的大爆炸理论,称之为宇宙膨胀理论。</p>
<p><img src="https://i.loli.net/2021/08/21/NAhJyOFkxjw5KM7.png" alt="image-20210821190117457"></p>
<p><img src="https://i.loli.net/2021/08/21/xBI4jgDqWcifOa8.png" alt="image-20210821190205447"></p>
<p><img src="https://i.loli.net/2021/08/21/gjOCwDdrFJ2eNzk.png" alt="image-20210821190334563"></p>
<p>acquisitive贪婪的</p>
<p>vulgar庸俗的; 粗俗的</p>
<p><img src="https://i.loli.net/2021/08/21/TojEsrVAhkgzXqY.png" alt="image-20210821190832259"></p>
<p><img src="https://i.loli.net/2021/08/21/xkb5orIXNByJfTm.png" alt="image-20210821190905791"></p>
<p><img src="https://i.loli.net/2021/08/21/hoUKTqJYpRmnaIf.png" alt="image-20210821191109500"></p>
<p>to the effect 大意是说(口语常见)</p>
<p><img src="https://i.loli.net/2021/08/21/dafERJUlZwAYWnS.png" alt="image-20210821191544703"></p>
<p>home appliance-&gt;家电</p>
<p>appliance-&gt;家电,器具</p>
<p>disorder-&gt;紊乱,失调,疾病</p>
<p>rage的心理学翻译——狂躁症</p>
<p>kitchen rage 厨房狂躁症</p>
<p><img src="https://i.loli.net/2021/08/23/p5mhwPJiVeFUz2D.png" alt="image-20210823144730405"></p>
<p>少用“被”字</p>
<p><img src="https://i.loli.net/2021/08/23/wAbxomRTgyjv5D8.png" alt="image-20210823145145737"></p>
<p><img src="https://i.loli.net/2021/08/23/xJ8cLtBo3q4ihZE.png" alt="image-20210823145209028"></p>
<p><img src="https://i.loli.net/2021/08/23/w5yzASsPEq9rt1Q.png" alt="image-20210823145524619"></p>
<p>my translation:</p>
<p>在转移时,传统的历史方法由额外的方法论扩大了,它用来解释历史研究中的新型证据</p>
<p>revision:</p>
<p>methodology ≈ historical method</p>
<p>designed to-&gt;旨在</p>
<p>correct translation:</p>
<p>在这种转化过程中,传统的历史研究方法上增加了新的历史研究方法,旨在解释历史研究中新的证据形式</p>
<p><img src="https://i.loli.net/2021/08/23/OrpMnPICwDhfyoB.png" alt="image-20210823151745872"></p>
<p><img src="https://i.loli.net/2021/08/23/SE2KYJleWLO4yTi.png" alt="image-20210823151758876"></p>
<p>my translation:</p>
<p>在一开始,它就导致讨论走向极端,它让你认为,动物应该被对待,从有着人类思维的一部分扩展到其他人类,甚至没有思维的</p>
<p>revision:</p>
<p>lead to-&gt;导致</p>
<p>lead ……to -&gt;把…引导向</p>
<p>either…or…-&gt;</p>
<p>consideration-&gt;关心</p>
<p>not…at all 一点也不</p>
<p><img src="https://i.loli.net/2021/08/23/gQDPt6UKpfirlCb.png" alt="image-20210823154808931"></p>
<p>correct translation:</p>
<p>这种观点从一开始就把讨论引向了极端,它让你(人们)认为,应该这样对待动物,要么像人类对待自己一样关心,要么一点也不关心。</p>
<p><img src="https://i.loli.net/2021/08/23/z2kwPfVxASHuB9t.png" alt="image-20210823155008808"></p>
<p>my translation:</p>
<p>一般来说,法律学习被看作律师特定知识储备的习惯,而非受教育人群知识储备的必要部分</p>
<p>传统上,人们将法律学习看作律师特定的知识储备,而非受教育人群知识储备所必须的一部分</p>
<p>revision:</p>
<p>institution-&gt;学院</p>
<p>correct translation:</p>
<p>传统上,这些学院把法律学习看作是律师的专长,而不是一个受过教育的人的知识储备的必要部分</p>
<p><img src="https://i.loli.net/2021/08/23/T7LBFiDxSv5qKol.png" alt="把...看作、认为"></p>
<p><img src="https://i.loli.net/2021/08/23/qDGpQrbsOcM694S.png" alt="image-20210823160523636"></p>
<p><img src="https://i.loli.net/2021/08/23/USjCuJ7mqxIWQBT.png" alt="image-20210823160557884"></p>
<p>my translation:</p>
<p>蘑菇云的存在事实上是需要大爆炸的,19世纪20年代的第一次投放,是为了维持其作为宇宙权威解释的统治地位</p>
<p>revision:</p>
<p>the giant clouds-&gt;巨大星云</p>
<p>be required for something to do对某人来说做某事是必要的</p>
<p>first put forward-&gt;首次提出</p>
<p>correct translation:</p>
<p>巨大宇宙云的存在实际上是20世纪20年代首次提出的大爆炸理论保持其作为对宇宙的主流解释所必须的</p>
<p><img src="https://i.loli.net/2021/08/23/mul4tKJhMQfpiPN.png" alt="image-20210823161835382"></p>
<p><img src="https://i.loli.net/2021/08/23/pWOgqkUG8xz7I3a.png" alt="image-20210823161915076"></p>
<p>my translation:</p>
<p>因此,在我们经过仔细考虑的广泛的教育过程中,它引导我们去辨别,一种更正式的教育—直接指导或者学校教育。</p>
<p>revision:</p>
<p>so far 迄今为止</p>
<p>correct translation:</p>
<p>因此,在我们迄今为止考虑到的更为宽泛的教育过程中,这使得我们去区别出,一种更为正式的教育形式,即直接教导或学校教育。</p>
<p><img src="https://i.loli.net/2021/08/23/Rni3Vuf8jNPdhvc.png" alt="image-20210823163623223"></p>
<p><img src="https://i.loli.net/2021/08/23/zbtajISeNudLT6i.png" alt="image-20210823172141550"></p>
<p>my translation:</p>
<p>仅在一百多年前,自然选择在进化中的作用就被确定,环境在形成和维持个体行为方面的选择性作用正开始被认识和研究</p>
<p>revisions:</p>
<p>formulate、articulate-&gt;阐明;阐述</p>
<p>correct translation:</p>
<p>自然选择在进化中的作用仅仅在一百多年前才得以阐明,在塑造和保持个体行为中环境的选择作用才刚刚加以认识和研究。</p>
<p><img src="https://i.loli.net/2021/08/23/2YjSkXmbJ5f9grH.png" alt="image-20210823173529840"></p>
<p>my translation:</p>
<p>这种情况发生时,这并没有错:这是人对行为道德推理的本能,这种本能应该得到鼓励而非嘲笑</p>
<p>revisions:</p>
<p>in action-&gt;起作用</p>
<p>correct translation:</p>
<p>当这种情况发生时,这不是一种错误:这是人类道德推理的本能在起作用,这种本能应该得到鼓励而不是遭到嘲笑</p>
<p><img src="https://i.loli.net/2021/08/23/x4iMGEjyC3cUWQD.png" alt="image-20210823180215200"></p>
<p>英语二:</p>
<p>先做英语一(2000-2010)的翻译题,每天一句翻译</p>
<p>2010-2021翻译题留到后面做模拟题</p>
<p><img src="https://i.loli.net/2021/08/23/7V8MowexIBSCJri.png" alt="image-20210823181533119"></p>
<p>additional 新的</p>
<p>就近修饰和一致原则(意思、逻辑一致)</p>
<p><img src="https://i.loli.net/2021/08/23/Upcf4CPTjh29GZ5.png" alt="image-20210823181958135"></p>
<p>arise from 由……引起</p>
<p>取决于:</p>
<p><img src="https://i.loli.net/2021/08/23/epOdKgtNynsVIB2.png" alt="image-20210823182032387"></p>
<p><img src="https://i.loli.net/2021/08/23/KGUao6mZhRdrTQl.png" alt="image-20210823182334612"></p>
<p>断句、划线、拆分</p>
<p><img src="https://i.loli.net/2021/08/23/dlki2EquIwxHBgm.png" alt="image-20210823182737819"></p>
<p>my translation:</p>
<p>在南堡罗用地基探测器和球状仪器的天文学家正在研究这样的结构,并且可能在不久之后发表他们的发现</p>
<p>revision:</p>
<p><img src="https://i.loli.net/2021/08/23/PLMciqZvzb52AJp.png" alt="image-20210823183552655"></p>
<p>astrophysicist-&gt;天体物理学家</p>
<p>close in on-&gt;靠近、逼近-&gt;研究</p>
<p>south pole-&gt;南极</p>
<p>detective-&gt;警察;侦探</p>
<p>用多重并列定于修饰</p>
<p><img src="https://i.loli.net/2021/08/23/7zYwSv5WjpXnuEx.png" alt="image-20210823184219762"></p>
<p><img src="https://i.loli.net/2021/08/23/IDO3QNjRprKsZyV.png" alt="image-20210823184757596"></p>
<p><img src="https://i.loli.net/2021/08/23/uPLlp6RTdihSWYF.png" alt="image-20210823185019283"></p>
<p>correct translation:</p>
<p>用位于南极的陆基探测器和球载仪器的天体物理学家,他们正在研究这样的结构,并且不久就会报告他们的报告结果。</p>
<p><img src="https://i.loli.net/2021/08/24/4e8kP5c2xHgVqdT.png" alt="image-20210824093625553"></p>
<p>my translation:</p>
<p>伽利略最大的成就是在1609年他是第一个将新发明望远镜转向天空证明行星围绕太阳而不是地球的人。</p>
<p>correct translation:</p>
<p>伽利略最伟大的成就在于,在1609年他是第一个用新发明的望远镜观察天空的人,以证明行星围绕太阳而不是地球旋转。</p>
<p><img src="https://i.loli.net/2021/08/24/zjKTHCYNEVey2gf.png" alt="image-20210824095510110"></p>
<p>my translation:</p>
<p>指向普遍历史工作或者研究技术的独特概念的方法论是否适合各种不同的历史研究分支,这个问题没有一致的答案。</p>
<p>revisions:</p>
<p>refer to-&gt;参考,引用-&gt;指</p>
<p>perculiar to</p>
<p><img src="https://i.loli.net/2021/08/24/SuYdO2vc9hoCbVe.png" alt="image-20210824101321097"></p>
<p><img src="https://i.loli.net/2021/08/24/y1sDHmCIxePuJad.png" alt="image-20210824101514800"></p>
<p>correct translation:</p>
<p>方法论是指一般历史研究所特有的概念,还是指适用于各种历史研究分支的研究方法,人们没有达成共识。</p>
<p><img src="https://i.loli.net/2021/08/24/MS5wHC2KYNP1rxT.png" alt="image-20210824102032470"></p>
<p>my translation:</p>
<p>他的作用与法官类似,必须接受在尽可能明显行为的推理课程中</p>
<p>revisions:</p>
<p><img src="https://i.loli.net/2021/08/24/cO5pW3rg2RKQXN8.png" alt="image-20210824102909936"></p>
<p>in manner 以…方式</p>
<p>correct translation:</p>
<p>(of短语太长了,拆分翻译)</p>
<p>他的作用类似于一个法官,他必须承担这样的责任:以尽可能明显的方式揭示导致他做决定的推理过程。</p>
<p><img src="https://i.loli.net/2021/08/24/tJiVCQDxIBraAsM.png" alt="image-20210824103603276"></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>英语翻译</tag>
        <tag>考研</tag>
        <tag>唐静</tag>
      </tags>
  </entry>
</search>
